{"code":"_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[31],{JlNr:function(e,r,t){e.exports={pageContainer:\"singup_pageContainer__34S6Y\",formContainer:\"singup_formContainer__1YGeD\",inputContainer:\"singup_inputContainer__2Gn17\",Header:\"singup_Header__10-IF\",descriptionHeader:\"singup_descriptionHeader__jc8pI\",btnContainer:\"singup_btnContainer__2Ex20\",messageToCreateAccounOrForgetPassword:\"singup_messageToCreateAccounOrForgetPassword__2hsIQ\",message:\"singup_message__2qTl8\",clickHere:\"singup_clickHere__kol6t\",forgetPassword:\"singup_forgetPassword__1icLy\",birthDay:\"singup_birthDay__2gLje\",switchContainer:\"singup_switchContainer__3uClR\",error:\"singup_error__usO7t\",close:\"singup_close__3Wcb3\"}},l50k:function(e,r,t){\"use strict\";t.r(r);var n=t(\"nKUr\"),s=t(\"ODXe\"),i=t(\"q1tI\"),c=t.n(i),a=t(\"JlNr\"),u=t.n(a),o=t(\"z+U2\"),l=t(\"YFqc\"),d=t.n(l),f=t(\"HEYe\"),b=t(\"z0pW\"),j=t.n(b),O=e=>e instanceof HTMLElement;const g=\"blur\",p=\"change\",m=\"input\",h=\"onBlur\",y=\"onChange\",v=\"onSubmit\",x=\"onTouched\",w=\"all\",C=\"undefined\",A=\"max\",V=\"min\",_=\"maxLength\",k=\"minLength\",R=\"pattern\",N=\"required\",S=\"validate\";var F=e=>null==e;const D=e=>\"object\"===typeof e;var E=e=>!F(e)&&!Array.isArray(e)&&D(e)&&!(e instanceof Date),T=e=>/^\\w*$/.test(e),q=e=>e.filter(Boolean),P=e=>q(e.replace(/[\"|']/g,\"\").replace(/\\[/g,\".\").replace(/\\]/g,\"\").split(\".\"));function L(e,r,t){let n=-1;const s=T(r)?[r]:P(r),i=s.length,c=i-1;for(;++n<i;){const r=s[n];let i=t;if(n!==c){const t=e[r];i=E(t)||Array.isArray(t)?t:isNaN(+s[n+1])?{}:[]}e[r]=i,e=e[r]}return e}var B=(e,r={})=>{for(const t in e)T(t)?r[t]=e[t]:L(r,t,e[t]);return r},H=e=>void 0===e,I=(e={},r,t)=>{const n=q(r.split(/[,[\\].]+?/)).reduce(((e,r)=>F(e)?e:e[r]),e);return H(n)||n===e?H(e[r])?t:e[r]:n},M=(e,r)=>{O(e)&&e.removeEventListener&&(e.removeEventListener(m,r),e.removeEventListener(p,r),e.removeEventListener(g,r))};const W={isValid:!1,value:null};var z=e=>Array.isArray(e)?e.reduce(((e,r)=>r&&r.ref.checked?{isValid:!0,value:r.ref.value}:e),W):W,U=e=>\"radio\"===e.type,Z=e=>\"file\"===e.type,$=e=>\"checkbox\"===e.type,J=e=>\"select-multiple\"===e.type;const G={value:!1,isValid:!1},Y={value:!0,isValid:!0};var X=e=>{if(Array.isArray(e)){if(e.length>1){const r=e.filter((e=>e&&e.ref.checked)).map((({ref:{value:e}})=>e));return{value:r,isValid:!!r.length}}const{checked:r,value:t,attributes:n}=e[0].ref;return r?n&&!H(n.value)?H(t)||\"\"===t?Y:{value:t,isValid:!0}:Y:G}return G};function K(e,r,t,n,s){const i=e.current[r];if(i){const{ref:{value:e,disabled:r},ref:t,valueAsNumber:a,valueAsDate:u,setValueAs:o}=i;if(r&&n)return;return Z(t)?t.files:U(t)?z(i.options).value:J(t)?(c=t.options,[...c].filter((({selected:e})=>e)).map((({value:e})=>e))):$(t)?X(i.options).value:s?e:a?\"\"===e?NaN:+e:u?t.valueAsDate:o?o(e):e}var c;if(t)return I(t.current,r)}function Q(e){return!e||e instanceof HTMLElement&&e.nodeType!==Node.DOCUMENT_NODE&&Q(e.parentNode)}var ee=e=>E(e)&&!Object.keys(e).length,re=e=>\"boolean\"===typeof e;function te(e,r){const t=T(r)?[r]:P(r),n=1==t.length?e:function(e,r){const t=r.slice(0,-1).length;let n=0;for(;n<t;)e=H(e)?n++:e[r[n++]];return e}(e,t),s=t[t.length-1];let i;n&&delete n[s];for(let c=0;c<t.slice(0,-1).length;c++){let r,n=-1;const s=t.slice(0,-(c+1)),a=s.length-1;for(c>0&&(i=e);++n<s.length;){const t=s[n];r=r?r[t]:e[t],a===n&&(E(r)&&ee(r)||Array.isArray(r)&&!r.filter((e=>E(e)&&!ee(e)||re(e))).length)&&(i?delete i[t]:delete e[t]),i=r}}return e}const ne=(e,r)=>e&&e.ref===r;var se=e=>F(e)||!D(e);function ie(e,r){if(se(e)||se(r))return r;for(const n in r){const s=e[n],i=r[n];try{e[n]=E(s)&&E(i)||Array.isArray(s)&&Array.isArray(i)?ie(s,i):i}catch(t){}}return e}function ce(e,r,t){if(se(e)||se(r)||e instanceof Date||r instanceof Date)return e===r;if(!Object(i.isValidElement)(e)){const n=Object.keys(e),s=Object.keys(r);if(n.length!==s.length)return!1;for(const i of n){const n=e[i];if(!t||\"ref\"!==i){const e=r[i];if((E(n)||Array.isArray(n))&&(E(e)||Array.isArray(e))?!ce(n,e,t):n!==e)return!1}}}return!0}function ae(e,r,t,n,s){let i=-1;for(;++i<e.length;){for(const n in e[i])Array.isArray(e[i][n])?(!t[i]&&(t[i]={}),t[i][n]=[],ae(e[i][n],I(r[i]||{},n,[]),t[i][n],t[i],n)):ce(I(r[i]||{},n),e[i][n])?L(t[i]||{},n):t[i]=Object.assign(Object.assign({},t[i]),{[n]:!0});n&&!t.length&&delete n[s]}return t}var ue=(e,r,t)=>ie(ae(e,r,t.slice(0,e.length)),ae(r,e,t.slice(0,e.length))),oe=e=>\"string\"===typeof e,le=(e,r,t,n,s)=>{const i={};for(const c in e.current)(H(s)||(oe(s)?c.startsWith(s):Array.isArray(s)&&s.find((e=>c.startsWith(e)))))&&(i[c]=K(e,c,void 0,n));return t?B(i):ie(r,B(i))},de=e=>e instanceof RegExp,fe=e=>E(e)&&!de(e)?e:{value:e,message:\"\"},be=e=>\"function\"===typeof e,je=e=>oe(e)||Object(i.isValidElement)(e);function Oe(e,r,t=\"validate\"){if(je(e)||re(e)&&!e)return{type:t,message:je(e)?e:\"\",ref:r}}var ge=(e,r,t,n,s)=>r?Object.assign(Object.assign({},t[e]),{types:Object.assign(Object.assign({},t[e]&&t[e].types?t[e].types:{}),{[n]:s||!0})}):{},pe=async(e,r,{ref:t,ref:{value:n},options:s,required:i,maxLength:c,minLength:a,min:u,max:o,pattern:l,validate:d},f)=>{const b=t.name,j={},O=U(t),g=$(t),p=O||g,m=\"\"===n,h=ge.bind(null,b,r,j),y=(e,r,n,s=_,i=k)=>{const c=e?r:n;j[b]=Object.assign({type:e?s:i,message:c,ref:t},h(e?s:i,c))};if(i&&(!O&&!g&&(m||F(n))||re(n)&&!n||g&&!X(s).isValid||O&&!z(s).isValid)){const{value:n,message:s}=je(i)?{value:!!i,message:i}:fe(i);if(n&&(j[b]=Object.assign({type:N,message:s,ref:p?((e.current[b].options||[])[0]||{}).ref:t},h(N,s)),!r))return j}if((!F(u)||!F(o))&&\"\"!==n){let e,s;const i=fe(o),c=fe(u);if(isNaN(n)){const r=t.valueAsDate||new Date(n);oe(i.value)&&(e=r>new Date(i.value)),oe(c.value)&&(s=r<new Date(c.value))}else{const r=t.valueAsNumber||parseFloat(n);F(i.value)||(e=r>i.value),F(c.value)||(s=r<c.value)}if((e||s)&&(y(!!e,i.message,c.message,A,V),!r))return j}if(oe(n)&&!m&&(c||a)){const e=fe(c),t=fe(a),s=!F(e.value)&&n.length>e.value,i=!F(t.value)&&n.length<t.value;if((s||i)&&(y(s,e.message,t.message),!r))return j}if(oe(n)&&l&&!m){const{value:e,message:s}=fe(l);if(de(e)&&!e.test(n)&&(j[b]=Object.assign({type:R,message:s,ref:t},h(R,s)),!r))return j}if(d){const n=K(e,b,f,!1,!0),i=p&&s?s[0].ref:t;if(be(d)){const e=Oe(await d(n),i);if(e&&(j[b]=Object.assign(Object.assign({},e),h(S,e.message)),!r))return j}else if(E(d)){let e={};for(const[t,s]of Object.entries(d)){if(!ee(e)&&!r)break;const c=Oe(await s(n),i,t);c&&(e=Object.assign(Object.assign({},c),h(t,c.message)),r&&(j[b]=e))}if(!ee(e)&&(j[b]=Object.assign({ref:i},e),!r))return j}}return j};const me=(e,r,t=[])=>{for(const n in r){const s=e+(E(r)?`.${n}`:`[${n}]`);se(r[n])?t.push(s):me(s,r[n],t)}return t};var he=(e,r,t,n,s)=>{let i;return t.add(r),ee(e)||(i=I(e,r),(E(i)||Array.isArray(i))&&me(r,i).forEach((e=>t.add(e)))),H(i)?s?n:I(n,r):i},ye=({isOnBlur:e,isOnChange:r,isOnTouch:t,isTouched:n,isReValidateOnBlur:s,isReValidateOnChange:i,isBlurEvent:c,isSubmitted:a,isOnAll:u})=>!u&&(!a&&t?!(n||c):(a?s:e)?!c:!(a?i:r)||c),ve=e=>e.substring(0,e.indexOf(\"[\"));const xe=(e,r)=>RegExp(`^${r}([|.)\\\\d+`.replace(/\\[/g,\"\\\\[\").replace(/\\]/g,\"\\\\]\")).test(e);var we=(e,r)=>[...e].some((e=>xe(r,e)));var Ce=typeof window!==C&&typeof document!==C;function Ae(e){var r;let t;if(se(e)||Ce&&(e instanceof File||O(e)))return e;if(![\"Set\",\"Map\",\"Object\",\"Date\",\"Array\"].includes(null===(r=e.constructor)||void 0===r?void 0:r.name))return e;if(e instanceof Date)return t=new Date(e.getTime()),t;if(e instanceof Set){t=new Set;for(const r of e)t.add(r);return t}if(e instanceof Map){t=new Map;for(const r of e.keys())t.set(r,Ae(e.get(r)));return t}t=Array.isArray(e)?[]:{};for(const n in e)t[n]=Ae(e[n]);return t}var Ve=e=>({isOnSubmit:!e||e===v,isOnBlur:e===h,isOnChange:e===y,isOnAll:e===w,isOnTouch:e===x}),_e=e=>U(e)||$(e);const ke=typeof window===C,Re=Ce?\"Proxy\"in window:typeof Proxy!==C;function Ne({mode:e=v,reValidateMode:r=y,resolver:t,context:n,defaultValues:s={},shouldFocusError:c=!0,shouldUnregister:a=!0,criteriaMode:u}={}){const o=Object(i.useRef)({}),l=Object(i.useRef)({}),d=Object(i.useRef)({}),f=Object(i.useRef)(new Set),b=Object(i.useRef)({}),j=Object(i.useRef)({}),h=Object(i.useRef)({}),x=Object(i.useRef)({}),C=Object(i.useRef)(s),A=Object(i.useRef)(!1),V=Object(i.useRef)(!1),_=Object(i.useRef)(),k=Object(i.useRef)({}),R=Object(i.useRef)({}),N=Object(i.useRef)(n),S=Object(i.useRef)(t),D=Object(i.useRef)(new Set),P=Object(i.useRef)(Ve(e)),{isOnSubmit:W,isOnTouch:z}=P.current,G=u===w,[Y,X]=Object(i.useState)({isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touched:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!W,errors:{}}),re=Object(i.useRef)({isDirty:!Re,dirtyFields:!Re,touched:!Re||z,isValidating:!Re,isSubmitting:!Re,isValid:!Re}),ie=Object(i.useRef)(Y),ae=Object(i.useRef)(),{isOnBlur:de,isOnChange:fe}=Object(i.useRef)(Ve(r)).current;N.current=n,S.current=t,ie.current=Y,k.current=a?{}:ee(k.current)?Ae(s):k.current;const je=Object(i.useCallback)(((e={})=>{A.current||(ie.current=Object.assign(Object.assign({},ie.current),e),X(ie.current))}),[]),Oe=()=>re.current.isValidating&&je({isValidating:!0}),ge=Object(i.useCallback)(((e,r,t=!1,n={},s)=>{let i=t||(({errors:e,name:r,error:t,validFields:n,fieldsWithValidation:s})=>{const i=H(t),c=I(e,r);return i&&!!c||!i&&!ce(c,t,!0)||i&&I(s,r)&&!I(n,r)})({errors:ie.current.errors,error:r,name:e,validFields:x.current,fieldsWithValidation:h.current});const c=I(ie.current.errors,e);r?(te(x.current,e),i=i||!c||!ce(c,r,!0),L(ie.current.errors,e,r)):((I(h.current,e)||S.current)&&(L(x.current,e,!0),i=i||c),te(ie.current.errors,e)),(i&&!F(t)||!ee(n)||re.current.isValidating)&&je(Object.assign(Object.assign(Object.assign({},n),S.current?{isValid:!!s}:{}),{isValidating:!1}))}),[]),xe=Object(i.useCallback)(((e,r)=>{const{ref:t,options:n}=o.current[e],s=Ce&&O(t)&&F(r)?\"\":r;U(t)?(n||[]).forEach((({ref:e})=>e.checked=e.value===s)):Z(t)&&!oe(s)?t.files=s:J(t)?[...t.options].forEach((e=>e.selected=s.includes(e.value))):$(t)&&n?n.length>1?n.forEach((({ref:e})=>e.checked=Array.isArray(s)?!!s.find((r=>r===e.value)):s===e.value)):n[0].ref.checked=!!s:t.value=s}),[]),Ne=Object(i.useCallback)(((e,r)=>{if(re.current.isDirty){const t=He();return e&&r&&L(t,e,r),!ce(t,C.current)}return!1}),[]),Se=Object(i.useCallback)(((e,r=!0)=>{if(re.current.isDirty||re.current.dirtyFields){const t=!ce(I(C.current,e),K(o,e,k)),n=I(ie.current.dirtyFields,e),s=ie.current.isDirty;t?L(ie.current.dirtyFields,e,!0):te(ie.current.dirtyFields,e);const i={isDirty:Ne(),dirtyFields:ie.current.dirtyFields},c=re.current.isDirty&&s!==i.isDirty||re.current.dirtyFields&&n!==I(ie.current.dirtyFields,e);return c&&r&&je(i),c?i:{}}return{}}),[]),Fe=Object(i.useCallback)((async(e,r)=>{const t=(await pe(o,G,o.current[e],k))[e];return ge(e,t,r),H(t)}),[ge,G]),De=Object(i.useCallback)((async e=>{const{errors:r}=await S.current(He(),N.current,G),t=ie.current.isValid;if(Array.isArray(e)){const t=e.map((e=>{const t=I(r,e);return t?L(ie.current.errors,e,t):te(ie.current.errors,e),!t})).every(Boolean);return je({isValid:ee(r),isValidating:!1}),t}{const n=I(r,e);return ge(e,n,t!==ee(r),{},ee(r)),!n}}),[ge,G]),Ee=Object(i.useCallback)((async e=>{const r=e||Object.keys(o.current);if(Oe(),S.current)return De(r);if(Array.isArray(r)){!e&&(ie.current.errors={});const t=await Promise.all(r.map((async e=>await Fe(e,null))));return je({isValidating:!1}),t.every(Boolean)}return await Fe(r)}),[De,Fe]),Te=Object(i.useCallback)(((e,r,{shouldDirty:t,shouldValidate:n})=>{const s={};L(s,e,r);for(const i of me(e,r))o.current[i]&&(xe(i,I(s,i)),t&&Se(i),n&&Ee(i))}),[Ee,xe,Se]),qe=Object(i.useCallback)(((e,r,t)=>{if(!a&&!se(r)&&L(k.current,e,Array.isArray(r)?[...r]:Object.assign({},r)),o.current[e])xe(e,r),t.shouldDirty&&Se(e),t.shouldValidate&&Ee(e);else if(!se(r)&&(Te(e,r,t),D.current.has(e))){const n=ve(e)||e;L(l.current,e,r),R.current[n]({[n]:I(l.current,n)}),(re.current.isDirty||re.current.dirtyFields)&&t.shouldDirty&&(L(ie.current.dirtyFields,e,ue(r,I(C.current,e,[]),I(ie.current.dirtyFields,e,[]))),je({isDirty:!ce(Object.assign(Object.assign({},He()),{[e]:r}),C.current)}))}!a&&L(k.current,e,r)}),[Se,xe,Te]),Pe=e=>V.current||f.current.has(e)||f.current.has((e.match(/\\w+/)||[])[0]),Le=e=>{let r=!0;if(!ee(b.current))for(const t in b.current)e&&b.current[t].size&&!b.current[t].has(e)&&!b.current[t].has(ve(e))||(j.current[t](),r=!1);return r};function Be(e){if(!a){let r=Ae(e);for(const e of D.current)T(e)&&!r[e]&&(r=Object.assign(Object.assign({},r),{[e]:[]}));return r}return e}function He(e){if(oe(e))return K(o,e,k);if(Array.isArray(e)){const r={};for(const t of e)L(r,t,K(o,t,k));return r}return Be(le(o,Ae(k.current),a))}_.current=_.current?_.current:async({type:e,target:r})=>{let t=r.name;const n=o.current[t];let s,i;if(n){const c=e===g,u=ye(Object.assign({isBlurEvent:c,isReValidateOnChange:fe,isReValidateOnBlur:de,isTouched:!!I(ie.current.touched,t),isSubmitted:ie.current.isSubmitted},P.current));let l=Se(t,!1),d=!ee(l)||!c&&Pe(t);if(c&&!I(ie.current.touched,t)&&re.current.touched&&(L(ie.current.touched,t,!0),l=Object.assign(Object.assign({},l),{touched:ie.current.touched})),!a&&$(r)&&L(k.current,t,K(o,t)),u)return!c&&Le(t),(!ee(l)||d&&ee(l))&&je(l);if(Oe(),S.current){const{errors:e}=await S.current(He(),N.current,G),n=ie.current.isValid;if(s=I(e,t),$(r)&&!s&&S.current){const r=ve(t),n=I(e,r,{});n.type&&n.message&&(s=n),r&&(n||I(ie.current.errors,r))&&(t=r)}i=ee(e),n!==i&&(d=!0)}else s=(await pe(o,G,n,k))[t];!c&&Le(t),ge(t,s,d,l,i)}};const Ie=Object(i.useCallback)((async(e={})=>{const r=ee(o.current)?C.current:{},{errors:t}=await S.current(Object.assign(Object.assign(Object.assign({},r),He()),e),N.current,G)||{},n=ee(t);ie.current.isValid!==n&&je({isValid:n})}),[G]),Me=Object(i.useCallback)(((e,r)=>{!function(e,r,t,n,s,i){const{ref:c,ref:{name:a}}=t,u=e.current[a];if(!s){const r=K(e,a,n);!H(r)&&L(n.current,a,r)}c.type&&u?U(c)||$(c)?Array.isArray(u.options)&&u.options.length?(q(u.options).forEach(((e={},t)=>{(Q(e.ref)&&ne(e,e.ref)||i)&&(M(e.ref,r),te(u.options,`[${t}]`))})),u.options&&!q(u.options).length&&delete e.current[a]):delete e.current[a]:(Q(c)&&ne(u,c)||i)&&(M(c,r),delete e.current[a]):delete e.current[a]}(o,_.current,e,k,a,r),a&&(te(x.current,e.ref.name),te(h.current,e.ref.name))}),[a]),We=Object(i.useCallback)((e=>{if(V.current)je();else{for(const r of f.current)if(r.startsWith(e)){je();break}Le(e)}}),[]),ze=Object(i.useCallback)(((e,r)=>{e&&(Me(e,r),a&&!q(e.options||[]).length&&(te(ie.current.errors,e.ref.name),L(ie.current.dirtyFields,e.ref.name,!0),je({isDirty:Ne()}),re.current.isValid&&S.current&&Ie(),We(e.ref.name)))}),[Ie,Me]);const Ue=Object(i.useCallback)(((e,r,t)=>{const n=t?b.current[t]:f.current;let s=le(o,Ae(k.current),a,!1,e);if(oe(e)){const t=ve(e)||e;return D.current.has(t)&&(s=Object.assign(Object.assign({},d.current),s)),he(s,e,n,H(I(C.current,e))?r:I(C.current,e),!0)}const i=H(r)?C.current:r;return Array.isArray(e)?e.reduce(((e,r)=>Object.assign(Object.assign({},e),{[r]:he(s,r,n,i)})),{}):(V.current=H(t),B(!ee(s)&&s||i))}),[]);function Ze(e,r={}){const{name:t,type:n,value:s}=e,i=Object.assign({ref:e},r),c=o.current,u=_e(e),l=we(D.current,t),d=r=>Ce&&(!O(e)||r===e);let f,b=c[t],j=!0;if(b&&(u?Array.isArray(b.options)&&q(b.options).find((e=>s===e.ref.value&&d(e.ref))):d(b.ref)))return void(c[t]=Object.assign(Object.assign({},b),r));b=n?u?Object.assign({options:[...q(b&&b.options||[]),{ref:e}],ref:{type:n,name:t}},r):Object.assign({},i):i,c[t]=b;const y=H(I(k.current,t));ee(C.current)&&y||(f=I(y?C.current:k.current,t),j=H(f),j||l||xe(t,f)),ee(r)||(L(h.current,t,!0),!W&&re.current.isValid&&pe(o,G,b,k).then((e=>{const r=ie.current.isValid;ee(e)?L(x.current,t,!0):te(x.current,t),r!==ee(e)&&je()}))),!a||l&&j||!l&&te(ie.current.dirtyFields,t),n&&function({ref:e},r,t){O(e)&&t&&(e.addEventListener(r?p:m,t),e.addEventListener(g,t))}(u&&b.options?b.options[b.options.length-1]:b,u||\"select-one\"===e.type,_.current)}const $e=Object(i.useCallback)(((e,r)=>async t=>{t&&t.preventDefault&&(t.preventDefault(),t.persist());let n={},s=Be(le(o,Ae(k.current),a,!0));re.current.isSubmitting&&je({isSubmitting:!0});try{if(S.current){const{errors:e,values:r}=await S.current(s,N.current,G);ie.current.errors=n=e,s=r}else for(const e of Object.values(o.current))if(e){const{name:r}=e.ref,t=await pe(o,G,e,k);t[r]?(L(n,r,t[r]),te(x.current,r)):I(h.current,r)&&(te(ie.current.errors,r),L(x.current,r,!0))}ee(n)&&Object.keys(ie.current.errors).every((e=>e in o.current))?(je({errors:{},isSubmitting:!0}),await e(s,t)):(ie.current.errors=Object.assign(Object.assign({},ie.current.errors),n),r&&await r(ie.current.errors,t),c&&((e,r)=>{for(const t in e)if(I(r,t)){const r=e[t];if(r){if(r.ref.focus&&H(r.ref.focus()))break;if(r.options){r.options[0].ref.focus();break}}}})(o.current,ie.current.errors))}finally{ie.current.isSubmitting=!1,je({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:ee(ie.current.errors),submitCount:ie.current.submitCount+1})}}),[c,G]);Object(i.useEffect)((()=>{t&&re.current.isValid&&Ie(),ae.current=ae.current||!Ce?ae.current:function(e,r){const t=new MutationObserver((()=>{for(const t of Object.values(e.current))if(t&&t.options)for(const e of t.options)e&&e.ref&&Q(e.ref)&&r(t);else t&&Q(t.ref)&&r(t)}));return t.observe(window.document,{childList:!0,subtree:!0}),t}(o,ze)}),[ze,C.current]),Object(i.useEffect)((()=>()=>{ae.current&&ae.current.disconnect(),A.current=!0,Object.values(o.current).forEach((e=>ze(e,!0)))}),[]),!t&&re.current.isValid&&(Y.isValid=ce(x.current,h.current)&&ee(ie.current.errors));const Je={trigger:Ee,setValue:Object(i.useCallback)((function(e,r,t){qe(e,r,t||{}),Pe(e)&&je(),Le(e)}),[qe,Ee]),getValues:Object(i.useCallback)(He,[]),register:Object(i.useCallback)((function(e,r){if(!ke)if(oe(e))Ze({name:e},r);else{if(!E(e)||!(\"name\"in e))return r=>r&&Ze(r,e);Ze(e,r)}}),[C.current]),unregister:Object(i.useCallback)((function(e){for(const r of Array.isArray(e)?e:[e])ze(o.current[r],!0)}),[]),formState:Re?new Proxy(Y,{get:(e,r)=>{if(r in e)return re.current[r]=!0,e[r]}}):Y},Ge=Object(i.useMemo)((()=>Object.assign({isFormDirty:Ne,updateWatchedValue:We,shouldUnregister:a,updateFormState:je,removeFieldEventListener:Me,watchInternal:Ue,mode:P.current,reValidateMode:{isReValidateOnBlur:de,isReValidateOnChange:fe},validateResolver:t?Ie:void 0,fieldsRef:o,resetFieldArrayFunctionRef:R,useWatchFieldsRef:b,useWatchRenderFunctionsRef:j,fieldArrayDefaultValuesRef:l,validFieldsRef:x,fieldsWithValidationRef:h,fieldArrayNamesRef:D,readFormStateRef:re,formStateRef:ie,defaultValuesRef:C,shallowFieldsStateRef:k,fieldArrayValuesRef:d},Je)),[C.current,We,a,Me,Ue]);return Object.assign({watch:function(e,r){return Ue(e,r)},control:Ge,handleSubmit:$e,reset:Object(i.useCallback)(((e,r={})=>{if(Ce)for(const n of Object.values(o.current))if(n){const{ref:e,options:r}=n,s=_e(e)&&Array.isArray(r)?r[0].ref:e;if(O(s))try{s.closest(\"form\").reset();break}catch(t){}}o.current={},C.current=Object.assign({},e||C.current),e&&Le(\"\"),Object.values(R.current).forEach((e=>be(e)&&e())),k.current=a?{}:Ae(e||C.current),(({errors:e,isDirty:r,isSubmitted:t,touched:n,isValid:s,submitCount:i,dirtyFields:c})=>{s||(x.current={},h.current={}),l.current={},f.current=new Set,V.current=!1,je({submitCount:i?ie.current.submitCount:0,isDirty:!!r&&ie.current.isDirty,isSubmitted:!!t&&ie.current.isSubmitted,isValid:!!s&&ie.current.isValid,dirtyFields:c?ie.current.dirtyFields:{},touched:n?ie.current.touched:{},errors:e?ie.current.errors:{},isSubmitting:!1,isSubmitSuccessful:!1})})(r)}),[]),clearErrors:Object(i.useCallback)((function(e){e&&(Array.isArray(e)?e:[e]).forEach((e=>o.current[e]&&T(e)?delete ie.current.errors[e]:te(ie.current.errors,e))),je({errors:e?ie.current.errors:{}})}),[]),setError:Object(i.useCallback)((function(e,r){const t=(o.current[e]||{}).ref;L(ie.current.errors,e,Object.assign(Object.assign({},r),{ref:t})),je({isValid:!1}),r.shouldFocus&&t&&t.focus&&t.focus()}),[]),errors:Y.errors},Je)}const Se=Object(i.createContext)(null);Se.displayName=\"RHFContext\";var Fe=t(\"LzO8\"),De=t(\"CGRP\"),Ee=t(\"GBzw\"),Te=t(\"BIE6\");t(\"Bec1\"),r.default=function(){var e=c.a.useContext(o.a),r=Object(s.a)(e,2),t=r[0],i=(r[1],c.a.useState(\"email\")),a=Object(s.a)(i,2),l=a[0],b=a[1],O=c.a.useState(\"1998-01-27T23:00:00.000Z\"),g=Object(s.a)(O,2),p=g[0],m=g[1],h=c.a.useState({state:!1,userid:\"\"}),y=Object(s.a)(h,2),v=y[0],x=y[1],w=Ne(),C=w.register,A=w.handleSubmit,V=w.errors,_=w.watch,k=c.a.useRef({});k.current=_(\"password\",\"\");var R=c.a.useState({state:!1,text:\"\"}),N=Object(s.a)(R,2),S=N[0],F=N[1],D=c.a.useContext(Te.a),E=Object(s.a)(D,2),T=(E[0],E[1]);return Object(n.jsxs)(\"div\",{className:u.a.pageContainer,children:[1==S.state&&Object(n.jsx)(Ee.a,{fnclose:function(){F({state:!1,text:\"\"})},openPopUp:S}),v.state&&Object(n.jsxs)(n.Fragment,{children:[Object(n.jsx)(\"div\",{className:u.a.close,onClick:function(){return x({state:!1,userid:\"\"})}}),Object(n.jsx)(De.a,{userId:v.userid})]}),Object(n.jsx)(\"div\",{className:u.a.formContainer,children:Object(n.jsxs)(\"form\",{onSubmit:A((function(e){T(!0),Object(Fe.f)(e).then((function(e){void 0==e.data?T(!1):0==e.data.state?(F({state:!0,text:e.data.message}),T(!1)):(x({state:!0,userid:e.data.userid}),T(!1))})).catch((function(e){F({state:!0,text:e.message}),T(!1)}))})),children:[Object(n.jsx)(\"input\",{name:\"age\",id:\"ageId\",defaultValue:\"1998-01-27T23:00:00.000Z\",ref:C({required:\"Required\"}),style:{position:\"absolute\",opacity:0,pointerEvents:\"none\"}}),Object(n.jsx)(\"div\",{className:u.a.Header,children:Object(n.jsx)(\"h1\",{children:\"Sing up For NOZZLA\"})}),Object(n.jsx)(\"div\",{className:u.a.descriptionHeader,children:Object(n.jsx)(\"h3\",{children:t.createaprofilefollowotheraccountstalkaboutyourownexperienceandmore})}),Object(n.jsxs)(\"div\",{className:u.a.inputContainer,children:[Object(n.jsx)(\"input\",{className:u.a.input,ref:C,name:\"userName\",required:!0}),Object(n.jsx)(\"label\",{children:Object(n.jsx)(\"span\",{children:t.username})})]}),Object(n.jsx)(\"div\",{className:u.a.switchContainer,children:Object(n.jsxs)(\"p\",{onClick:function(){b((function(e){return\"tel\"==e?\"email\":\"tel\"}))},children:[\"siwtch to \",\"tel\"==l?\"email\":\"tel\"]})}),Object(n.jsxs)(\"div\",{className:\"\".concat(u.a.inputContainerTelOrEmail),children:[Object(n.jsx)(\"input\",{type:\"text\",name:\"tel\",style:{position:\"absolute\",pointerEvents:\"none\",opacity:0}}),\"tel\"==l&&Object(n.jsxs)(n.Fragment,{children:[Object(n.jsx)(\"input\",{name:\"tel\",id:\"telId\",ref:C({required:\"Required\"}),style:{position:\"absolute\",opacity:0,pointerEvents:\"none\"}}),Object(n.jsx)(j.a,{name:\"tel\",specialLabel:t.phone,country:\"tn\",inputProps:{name:\"phone\",required:!0,autoFocus:!0},onChange:function(e,r){return function(e,r){document.querySelector(\"#telId\").value=JSON.stringify({dialCode:r.dialCode,tel:e})}(e,r)}})]}),\"email\"==l&&Object(n.jsxs)(\"div\",{className:u.a.inputContainer,children:[Object(n.jsx)(\"input\",{name:\"email\",ref:C({required:\"Required\",pattern:{value:/^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,message:\"invalid email address\"}}),className:u.a.input,required:!0}),Object(n.jsx)(\"label\",{children:Object(n.jsx)(\"span\",{children:\"email\"})})]})]}),V.tel&&Object(n.jsx)(\"div\",{className:u.a.error,children:Object(n.jsx)(\"p\",{children:\"tel is required\"})}),V.email&&Object(n.jsx)(\"div\",{className:u.a.error,children:Object(n.jsx)(\"p\",{children:\"email is incorect\"})}),Object(n.jsxs)(\"div\",{className:u.a.inputContainer,children:[Object(n.jsx)(\"input\",{name:\"password\",type:\"password\",ref:C({required:\"password required\",minLength:8}),className:u.a.input,required:!0}),Object(n.jsx)(\"label\",{children:Object(n.jsx)(\"span\",{children:t.password})})]}),V.password&&Object(n.jsx)(\"div\",{className:u.a.error,children:Object(n.jsx)(\"p\",{children:\"password length must be 8 at least\"})}),Object(n.jsxs)(\"div\",{className:u.a.inputContainer,children:[Object(n.jsx)(\"input\",{name:\"confirmPassword\",type:\"password\",ref:C({validate:function(e){return e===k.current||\"The passwords do not match\"}}),className:u.a.input,required:!0}),Object(n.jsx)(\"label\",{children:Object(n.jsx)(\"span\",{children:t.confirmpassword})})]}),V.confirmPassword&&Object(n.jsxs)(\"div\",{className:u.a.error,children:[\" \",Object(n.jsx)(\"p\",{children:V.confirmPassword.message})]}),Object(n.jsx)(\"div\",{className:\"\".concat(u.a.inputContainer,\" \").concat(u.a.birthDay),children:Object(n.jsx)(f.DatePicker,{value:p,onChange:function(e){return m(r=e),void(document.querySelector(\"#ageId\").value=r);var r},label:\"birth Day\",formatStyle:\"large\",locale:t.age})}),V.age&&Object(n.jsx)(\"div\",{className:u.a.error,children:Object(n.jsx)(\"p\",{children:\"age is required\"})}),Object(n.jsx)(\"div\",{className:u.a.btnContainer,children:Object(n.jsx)(\"button\",{children:t.signin})}),Object(n.jsx)(\"div\",{className:u.a.messageToCreateAccounOrForgetPassword,children:Object(n.jsxs)(\"p\",{className:u.a.message,children:[t.AlreadyHaveAccount,\" \",Object(n.jsx)(d.a,{href:\"/signin\",children:Object(n.jsx)(\"span\",{className:u.a.clickHere,children:t.signin})}),Object(n.jsx)(\"br\",{}),\" \",Object(n.jsx)(d.a,{href:\"/forgetPassword\",children:Object(n.jsx)(\"span\",{className:u.a.forgetPassword,children:t.ForgotPassword})})]})})]})})]})}},xp7T:function(e,r,t){(window.__NEXT_P=window.__NEXT_P||[]).push([\"/singup\",function(){return t(\"l50k\")}])}},[[\"xp7T\",0,2,11,8,6,7,1,3,5,4,9,10]]]);","map":{"version":3,"sources":["static/chunks/pages/singup-a74edb01e14dc4465d44.js"],"names":["_N_E","window","push","JlNr","module","exports","__webpack_require__","pageContainer","formContainer","inputContainer","Header","descriptionHeader","btnContainer","messageToCreateAccounOrForgetPassword","message","clickHere","forgetPassword","birthDay","switchContainer","error","close","l50k","__webpack_exports__","r","jsx_runtime","slicedToArray","react","react_default","n","singup_module","singup_module_default","languageContext","next_link","link_default","react_rainbow_components","lib","lib_default","isHTMLElement","value","HTMLElement","EVENTS","VALIDATION_MODE","UNDEFINED","INPUT_VALIDATION_RULES","isNullOrUndefined","isObjectType","isObject","Array","isArray","Date","isKey","test","compact","filter","Boolean","stringToPath","input","replace","split","set","object","path","index","tempPath","length","lastIndex","key","newValue","objValue","isNaN","transformToNestObject","data","isUndefined","val","undefined","get","obj","defaultValue","result","reduce","removeAllEventListeners","ref","validateWithStateUpdate","removeEventListener","defaultReturn","isValid","getRadioValue","options","previous","option","checked","isRadioInput","element","type","isFileInput","isCheckBoxInput","isMultipleSelect","defaultResult","validResult","getCheckboxValue","values","map","attributes","getFieldValue","fieldsRef","name","shallowFieldsStateRef","excludeDisabled","shouldKeepRawValue","field","current","disabled","valueAsNumber","valueAsDate","setValueAs","files","selected","NaN","isDetached","nodeType","Node","DOCUMENT_NODE","parentNode","isEmptyObject","Object","keys","isBoolean","unset","updatePath","childObject","slice","baseGet","previousObjRef","k","objectRef","currentPaths","currentPathsLength","item","isSameRef","fieldValue","isPrimitive","deepMerge","target","source","targetValue","sourceValue","_a","deepEqual","object1","object2","isErrorObject","keys1","keys2","val1","val2","setDirtyFields","defaultValues","dirtyFields","parentName","assign","[object Object]","setFieldArrayDirtyFields","isString","getFieldsValues","shallowFieldsState","shouldUnregister","search","output","startsWith","find","isRegex","RegExp","getValueAndMessage","validationData","isFunction","isMessage","getValidateError","appendErrors","validateAllFieldCriteria","errors","types","validateField","async","required","maxLength","minLength","min","max","pattern","validate","isRadio","isCheckBox","isRadioOrCheckbox","isEmpty","appendErrorsCurry","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","exceedMin","maxOutput","minOutput","valueDate","valueNumber","parseFloat","maxLengthOutput","minLengthOutput","patternValue","validateRef","validateError","validationResult","validateFunction","entries","getPath","rootPath","paths","property","rootName","assignWatchFields","fieldValues","fieldName","watchFields","inputValue","isSingleField","add","forEach","skipValidation","isOnBlur","isOnChange","isOnTouch","isTouched","isReValidateOnBlur","isReValidateOnChange","isBlurEvent","isSubmitted","isOnAll","getFieldArrayParentName","substring","indexOf","isMatchFieldArrayName","searchName","isNameInFieldArray","names","some","isWeb","document","cloneObject","copy","File","includes","constructor","getTime","Set","Map","modeChecker","mode","isOnSubmit","isRadioOrCheckboxFunction","isWindowUndefined","isProxyEnabled","Proxy","useForm","reValidateMode","resolver","context","shouldFocusError","criteriaMode","fieldArrayDefaultValuesRef","fieldArrayValuesRef","watchFieldsRef","useWatchFieldsRef","useWatchRenderFunctionsRef","fieldsWithValidationRef","validFieldsRef","defaultValuesRef","isUnMount","isWatchAllRef","handleChangeRef","resetFieldArrayFunctionRef","contextRef","resolverRef","fieldArrayNamesRef","modeRef","isValidateAllFieldCriteria","formState","setFormState","isDirty","isValidating","submitCount","touched","isSubmitting","isSubmitSuccessful","readFormStateRef","formStateRef","observerRef","updateFormState","state","updateIsValidating","shouldRenderBaseOnError","shouldRender","shouldReRender","validFields","fieldsWithValidation","previousError","isErrorStateChanged","setFieldValue","rawValue","radioRef","selectRef","checkboxRef","isFormDirty","formValues","getValues","updateAndGetDirtyState","isFieldDirty","isDirtyFieldExist","previousIsDirty","isChanged","executeValidation","skipReRender","executeSchemaOrResolverValidation","previousFormIsValid","isInputsValid","every","trigger","fields","Promise","all","setInternalValues","shouldDirty","shouldValidate","setInternalValue","config","has","isFieldWatched","match","renderWatchedInputs","found","size","setFieldArrayDefaultValues","payload","shouldSkipValidation","parentNodeName","currentError","validateResolver","newDefaultValues","removeFieldEventListener","forceDelete","handleChange","fieldRef","findRemovedFieldAndRemoveListener","updateWatchedValue","watchField","removeFieldEventListenerAndRef","watchInternal","fieldNames","watchId","combinedDefaultValues","registerFieldRef","fieldRefAndValidationOptions","isFieldArray","compareRef","currentRef","isEmptyDefaultValue","isEmptyUnmountFields","then","shouldAttachChangeEvent","addEventListener","attachEventListeners","handleSubmit","onValid","onInvalid","e","preventDefault","persist","fieldErrors","fieldError","focus","focusOnErrorField","observer","MutationObserver","observe","childList","subtree","onDomRemove","disconnect","commonProps","setValue","register","refOrRegisterOptions","unregister","prop","control","watch","reset","omitResetState","inputRef","closest","resetFieldArray","resetRefs","clearErrors","inputName","setError","shouldFocus","FormContext","displayName","user","verifyAccount","popUpMessage","apiIsLoadingContext","_React$useContext","a","useContext","_React$useContext2","language","_React$useState","useState","_React$useState2","showEmailOrTel","setShowEmailOrTel","_React$useState3","_React$useState4","setBirthDay","_React$useState5","userid","_React$useState6","openVerifieAccountModal","setOpenVerifieAccountModal","_useForm","password","useRef","_React$useState7","text","_React$useState8","errorMessage","setErrorMessage","_React$useContext3","_React$useContext4","setIsLoading","className","children","fnclose","openPopUp","onClick","userId","onSubmit","res","id","style","position","opacity","pointerEvents","createaprofilefollowotheraccountstalkaboutyourownexperienceandmore","username","concat","inputContainerTelOrEmail","specialLabel","phone","country","inputProps","autoFocus","onChange","querySelector","JSON","stringify","dialCode","tel","onChangeHandlerRegisterPhone","email","confirmpassword","confirmPassword","date","label","formatStyle","locale","age","signin","AlreadyHaveAccount","href","ForgotPassword","xp7T","__NEXT_P"],"mappings":"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"},"name":"static/chunks/pages/singup-a74edb01e14dc4465d44.js","input":"_N_E =\n(window[\"webpackJsonp_N_E\"] = window[\"webpackJsonp_N_E\"] || []).push([[31],{\n\n/***/ \"JlNr\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\nmodule.exports = {\"pageContainer\":\"singup_pageContainer__34S6Y\",\"formContainer\":\"singup_formContainer__1YGeD\",\"inputContainer\":\"singup_inputContainer__2Gn17\",\"Header\":\"singup_Header__10-IF\",\"descriptionHeader\":\"singup_descriptionHeader__jc8pI\",\"btnContainer\":\"singup_btnContainer__2Ex20\",\"messageToCreateAccounOrForgetPassword\":\"singup_messageToCreateAccounOrForgetPassword__2hsIQ\",\"message\":\"singup_message__2qTl8\",\"clickHere\":\"singup_clickHere__kol6t\",\"forgetPassword\":\"singup_forgetPassword__1icLy\",\"birthDay\":\"singup_birthDay__2gLje\",\"switchContainer\":\"singup_switchContainer__3uClR\",\"error\":\"singup_error__usO7t\",\"close\":\"singup_close__3Wcb3\"};\n\n/***/ }),\n\n/***/ \"l50k\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__(\"nKUr\");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 3 modules\nvar slicedToArray = __webpack_require__(\"ODXe\");\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(\"q1tI\");\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: ./styles/singup.module.scss\nvar singup_module = __webpack_require__(\"JlNr\");\nvar singup_module_default = /*#__PURE__*/__webpack_require__.n(singup_module);\n\n// EXTERNAL MODULE: ./context/languageContext.js\nvar languageContext = __webpack_require__(\"z+U2\");\n\n// EXTERNAL MODULE: ./node_modules/next/link.js\nvar next_link = __webpack_require__(\"YFqc\");\nvar link_default = /*#__PURE__*/__webpack_require__.n(next_link);\n\n// EXTERNAL MODULE: ./node_modules/react-rainbow-components/index.js\nvar react_rainbow_components = __webpack_require__(\"HEYe\");\n\n// EXTERNAL MODULE: ./node_modules/react-phone-input-2/lib/lib.js\nvar lib = __webpack_require__(\"z0pW\");\nvar lib_default = /*#__PURE__*/__webpack_require__.n(lib);\n\n// CONCATENATED MODULE: ./node_modules/react-hook-form/dist/index.esm.js\n\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst SELECT = 'select';\r\nconst UNDEFINED = 'undefined';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nfunction attachEventListeners({ ref }, shouldAttachChangeEvent, handleChange) {\r\n    if (isHTMLElement(ref) && handleChange) {\r\n        ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n        ref.addEventListener(EVENTS.BLUR, handleChange);\r\n    }\r\n}\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !(value instanceof Date);\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar stringToPath = (input) => compact(input\r\n    .replace(/[\"|']/g, '')\r\n    .replace(/\\[/g, '.')\r\n    .replace(/\\]/g, '')\r\n    .split('.'));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar transformToNestObject = (data, value = {}) => {\r\n    for (const key in data) {\r\n        !isKey(key) ? set(value, key, data[key]) : (value[key] = data[key]);\r\n    }\r\n    return value;\r\n};\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj = {}, path, defaultValue) => {\r\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\r\n    for (const key in fields) {\r\n        if (get(fieldErrors, key)) {\r\n            const field = fields[key];\r\n            if (field) {\r\n                if (field.ref.focus && isUndefined(field.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (field.options) {\r\n                    field.options[0].ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (isHTMLElement(ref) && ref.removeEventListener) {\r\n        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n    }\r\n};\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.ref.checked\r\n        ? {\r\n            isValid: true,\r\n            value: option.ref.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.ref.checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || value === ''\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled, shouldKeepRawValue) {\r\n    const field = fieldsRef.current[name];\r\n    if (field) {\r\n        const { ref: { value, disabled }, ref, valueAsNumber, valueAsDate, setValueAs, } = field;\r\n        if (disabled && excludeDisabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field.options).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field.options).value;\r\n        }\r\n        return shouldKeepRawValue\r\n            ? value\r\n            : valueAsNumber\r\n                ? value === ''\r\n                    ? NaN\r\n                    : +value\r\n                : valueAsDate\r\n                    ? ref.valueAsDate\r\n                    : setValueAs\r\n                        ? setValueAs(value)\r\n                        : value;\r\n    }\r\n    if (shallowFieldsStateRef) {\r\n        return get(shallowFieldsStateRef.current, name);\r\n    }\r\n}\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\r\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {\r\n    const { ref, ref: { name }, } = field;\r\n    const fieldRef = fieldsRef.current[name];\r\n    if (!shouldUnregister) {\r\n        const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\r\n        !isUndefined(value) && set(shallowFieldsStateRef.current, name, value);\r\n    }\r\n    if (!ref.type || !fieldRef) {\r\n        delete fieldsRef.current[name];\r\n        return;\r\n    }\r\n    if (isRadioInput(ref) || isCheckBoxInput(ref)) {\r\n        if (Array.isArray(fieldRef.options) && fieldRef.options.length) {\r\n            compact(fieldRef.options).forEach((option = {}, index) => {\r\n                if ((isDetached(option.ref) && isSameRef(option, option.ref)) ||\r\n                    forceDelete) {\r\n                    removeAllEventListeners(option.ref, handleChange);\r\n                    unset(fieldRef.options, `[${index}]`);\r\n                }\r\n            });\r\n            if (fieldRef.options && !compact(fieldRef.options).length) {\r\n                delete fieldsRef.current[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fieldsRef.current[name];\r\n        }\r\n    }\r\n    else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        delete fieldsRef.current[name];\r\n    }\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction deepEqual(object1, object2, isErrorObject) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        object1 instanceof Date ||\r\n        object2 instanceof Date) {\r\n        return object1 === object2;\r\n    }\r\n    if (!Object(react[\"isValidElement\"])(object1)) {\r\n        const keys1 = Object.keys(object1);\r\n        const keys2 = Object.keys(object2);\r\n        if (keys1.length !== keys2.length) {\r\n            return false;\r\n        }\r\n        for (const key of keys1) {\r\n            const val1 = object1[key];\r\n            if (!(isErrorObject && key === 'ref')) {\r\n                const val2 = object2[key];\r\n                if ((isObject(val1) || Array.isArray(val1)) &&\r\n                    (isObject(val2) || Array.isArray(val2))\r\n                    ? !deepEqual(val1, val2, isErrorObject)\r\n                    : val1 !== val2) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nvar isString = (value) => typeof value === 'string';\n\nvar getFieldsValues = (fieldsRef, shallowFieldsState, shouldUnregister, excludeDisabled, search) => {\r\n    const output = {};\r\n    for (const name in fieldsRef.current) {\r\n        if (isUndefined(search) ||\r\n            (isString(search)\r\n                ? name.startsWith(search)\r\n                : Array.isArray(search) && search.find((data) => name.startsWith(data)))) {\r\n            output[name] = getFieldValue(fieldsRef, name, undefined, excludeDisabled);\r\n        }\r\n    }\r\n    return shouldUnregister\r\n        ? transformToNestObject(output)\r\n        : deepMerge(shallowFieldsState, transformToNestObject(output));\r\n};\n\nvar isErrorStateChanged = ({ errors, name, error, validFields, fieldsWithValidation, }) => {\r\n    const isValid = isUndefined(error);\r\n    const previousError = get(errors, name);\r\n    return ((isValid && !!previousError) ||\r\n        (!isValid && !deepEqual(previousError, error, true)) ||\r\n        (isValid && get(fieldsWithValidation, name) && !get(validFields, name)));\r\n};\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isMessage = (value) => isString(value) || Object(react[\"isValidElement\"])(value);\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { value }, options, required, maxLength, minLength, min, max, pattern, validate, }, shallowFieldsStateRef) => {\r\n    const name = ref.name;\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = value === '';\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, (exceedMax\r\n            ? appendErrorsCurry(maxType, message)\r\n            : appendErrorsCurry(minType, message)));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox\r\n                    ? ((fieldsRef.current[name].options || [])[0] || {}).ref\r\n                    : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) && value !== '') {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(value)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(value);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            value.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            value.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && pattern && !isEmpty) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef, false, true);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(fieldValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nconst getPath = (rootPath, values, paths = []) => {\r\n    for (const property in values) {\r\n        const rootName = (rootPath +\r\n            (isObject(values)\r\n                ? `.${property}`\r\n                : `[${property}]`));\r\n        isPrimitive(values[property])\r\n            ? paths.push(rootName)\r\n            : getPath(rootName, values[property], paths);\r\n    }\r\n    return paths;\r\n};\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\r\n    let value = undefined;\r\n    watchFields.add(fieldName);\r\n    if (!isEmptyObject(fieldValues)) {\r\n        value = get(fieldValues, fieldName);\r\n        if (isObject(value) || Array.isArray(value)) {\r\n            getPath(fieldName, value).forEach((name) => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isSingleField\r\n            ? inputValue\r\n            : get(inputValue, fieldName)\r\n        : value;\r\n};\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}([|.)\\\\d+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\r\nvar isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = (element) => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {\r\n    const observer = new MutationObserver(() => {\r\n        for (const field of Object.values(fieldsRef.current)) {\r\n            if (field && field.options) {\r\n                for (const option of field.options) {\r\n                    if (option && option.ref && isDetached(option.ref)) {\r\n                        removeFieldEventListenerAndRef(field);\r\n                    }\r\n                }\r\n            }\r\n            else if (field && isDetached(field.ref)) {\r\n                removeFieldEventListenerAndRef(field);\r\n            }\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nvar isWeb = typeof window !== UNDEFINED && typeof document !== UNDEFINED;\n\nfunction cloneObject(data) {\r\n    var _a;\r\n    let copy;\r\n    if (isPrimitive(data) ||\r\n        (isWeb && (data instanceof File || isHTMLElement(data)))) {\r\n        return data;\r\n    }\r\n    if (!['Set', 'Map', 'Object', 'Date', 'Array'].includes((_a = data.constructor) === null || _a === void 0 ? void 0 : _a.name)) {\r\n        return data;\r\n    }\r\n    if (data instanceof Date) {\r\n        copy = new Date(data.getTime());\r\n        return copy;\r\n    }\r\n    if (data instanceof Set) {\r\n        copy = new Set();\r\n        for (const item of data) {\r\n            copy.add(item);\r\n        }\r\n        return copy;\r\n    }\r\n    if (data instanceof Map) {\r\n        copy = new Map();\r\n        for (const key of data.keys()) {\r\n            copy.set(key, cloneObject(data.get(key)));\r\n        }\r\n        return copy;\r\n    }\r\n    copy = Array.isArray(data) ? [] : {};\r\n    for (const key in data) {\r\n        copy[key] = cloneObject(data[key]);\r\n    }\r\n    return copy;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nconst isWindowUndefined = typeof window === UNDEFINED;\r\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, shouldUnregister = true, criteriaMode, } = {}) {\r\n    const fieldsRef = Object(react[\"useRef\"])({});\r\n    const fieldArrayDefaultValuesRef = Object(react[\"useRef\"])({});\r\n    const fieldArrayValuesRef = Object(react[\"useRef\"])({});\r\n    const watchFieldsRef = Object(react[\"useRef\"])(new Set());\r\n    const useWatchFieldsRef = Object(react[\"useRef\"])({});\r\n    const useWatchRenderFunctionsRef = Object(react[\"useRef\"])({});\r\n    const fieldsWithValidationRef = Object(react[\"useRef\"])({});\r\n    const validFieldsRef = Object(react[\"useRef\"])({});\r\n    const defaultValuesRef = Object(react[\"useRef\"])(defaultValues);\r\n    const isUnMount = Object(react[\"useRef\"])(false);\r\n    const isWatchAllRef = Object(react[\"useRef\"])(false);\r\n    const handleChangeRef = Object(react[\"useRef\"])();\r\n    const shallowFieldsStateRef = Object(react[\"useRef\"])({});\r\n    const resetFieldArrayFunctionRef = Object(react[\"useRef\"])({});\r\n    const contextRef = Object(react[\"useRef\"])(context);\r\n    const resolverRef = Object(react[\"useRef\"])(resolver);\r\n    const fieldArrayNamesRef = Object(react[\"useRef\"])(new Set());\r\n    const modeRef = Object(react[\"useRef\"])(modeChecker(mode));\r\n    const { isOnSubmit, isOnTouch } = modeRef.current;\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const [formState, setFormState] = Object(react[\"useState\"])({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touched: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: !isOnSubmit,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = Object(react[\"useRef\"])({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touched: !isProxyEnabled || isOnTouch,\r\n        isValidating: !isProxyEnabled,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const formStateRef = Object(react[\"useRef\"])(formState);\r\n    const observerRef = Object(react[\"useRef\"])();\r\n    const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = Object(react[\"useRef\"])(modeChecker(reValidateMode)).current;\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    formStateRef.current = formState;\r\n    shallowFieldsStateRef.current = shouldUnregister\r\n        ? {}\r\n        : isEmptyObject(shallowFieldsStateRef.current)\r\n            ? cloneObject(defaultValues)\r\n            : shallowFieldsStateRef.current;\r\n    const updateFormState = Object(react[\"useCallback\"])((state = {}) => {\r\n        if (!isUnMount.current) {\r\n            formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);\r\n            setFormState(formStateRef.current);\r\n        }\r\n    }, []);\r\n    const updateIsValidating = () => readFormStateRef.current.isValidating &&\r\n        updateFormState({\r\n            isValidating: true,\r\n        });\r\n    const shouldRenderBaseOnError = Object(react[\"useCallback\"])((name, error, shouldRender = false, state = {}, isValid) => {\r\n        let shouldReRender = shouldRender ||\r\n            isErrorStateChanged({\r\n                errors: formStateRef.current.errors,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        if (error) {\r\n            unset(validFieldsRef.current, name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    !previousError ||\r\n                    !deepEqual(previousError, error, true);\r\n            set(formStateRef.current.errors, name, error);\r\n        }\r\n        else {\r\n            if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\r\n                set(validFieldsRef.current, name, true);\r\n                shouldReRender = shouldReRender || previousError;\r\n            }\r\n            unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((shouldReRender && !isNullOrUndefined(shouldRender)) ||\r\n            !isEmptyObject(state) ||\r\n            readFormStateRef.current.isValidating) {\r\n            updateFormState(Object.assign(Object.assign(Object.assign({}, state), (resolverRef.current ? { isValid: !!isValid } : {})), { isValidating: false }));\r\n        }\r\n    }, []);\r\n    const setFieldValue = Object(react[\"useCallback\"])((name, rawValue) => {\r\n        const { ref, options } = fieldsRef.current[name];\r\n        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(ref)) {\r\n            (options || []).forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isFileInput(ref) && !isString(value)) {\r\n            ref.files = value;\r\n        }\r\n        else if (isMultipleSelect(ref)) {\r\n            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(ref) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = Array.isArray(value)\r\n                    ? !!value.find((data) => data === checkboxRef.value)\r\n                    : value === checkboxRef.value))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n    }, []);\r\n    const isFormDirty = Object(react[\"useCallback\"])((name, data) => {\r\n        if (readFormStateRef.current.isDirty) {\r\n            const formValues = getValues();\r\n            name && data && set(formValues, name, data);\r\n            return !deepEqual(formValues, defaultValuesRef.current);\r\n        }\r\n        return false;\r\n    }, []);\r\n    const updateAndGetDirtyState = Object(react[\"useCallback\"])((name, shouldRender = true) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), getFieldValue(fieldsRef, name, shallowFieldsStateRef));\r\n            const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            isFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            const state = {\r\n                isDirty: isFormDirty(),\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            };\r\n            const isChanged = (readFormStateRef.current.isDirty &&\r\n                previousIsDirty !== state.isDirty) ||\r\n                (readFormStateRef.current.dirtyFields &&\r\n                    isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\r\n            isChanged && shouldRender && updateFormState(state);\r\n            return isChanged ? state : {};\r\n        }\r\n        return {};\r\n    }, []);\r\n    const executeValidation = Object(react[\"useCallback\"])(async (name, skipReRender) => {\r\n        if (false) {}\r\n        const error = (await validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef))[name];\r\n        shouldRenderBaseOnError(name, error, skipReRender);\r\n        return isUndefined(error);\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = Object(react[\"useCallback\"])(async (names) => {\r\n        const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n        const previousFormIsValid = formStateRef.current.isValid;\r\n        if (Array.isArray(names)) {\r\n            const isInputsValid = names\r\n                .map((name) => {\r\n                const error = get(errors, name);\r\n                error\r\n                    ? set(formStateRef.current.errors, name, error)\r\n                    : unset(formStateRef.current.errors, name);\r\n                return !error;\r\n            })\r\n                .every(Boolean);\r\n            updateFormState({\r\n                isValid: isEmptyObject(errors),\r\n                isValidating: false,\r\n            });\r\n            return isInputsValid;\r\n        }\r\n        else {\r\n            const error = get(errors, names);\r\n            shouldRenderBaseOnError(names, error, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));\r\n            return !error;\r\n        }\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const trigger = Object(react[\"useCallback\"])(async (name) => {\r\n        const fields = name || Object.keys(fieldsRef.current);\r\n        updateIsValidating();\r\n        if (resolverRef.current) {\r\n            return executeSchemaOrResolverValidation(fields);\r\n        }\r\n        if (Array.isArray(fields)) {\r\n            !name && (formStateRef.current.errors = {});\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, null)));\r\n            updateFormState({\r\n                isValidating: false,\r\n            });\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields);\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = Object(react[\"useCallback\"])((name, value, { shouldDirty, shouldValidate }) => {\r\n        const data = {};\r\n        set(data, name, value);\r\n        for (const fieldName of getPath(name, value)) {\r\n            if (fieldsRef.current[fieldName]) {\r\n                setFieldValue(fieldName, get(data, fieldName));\r\n                shouldDirty && updateAndGetDirtyState(fieldName);\r\n                shouldValidate && trigger(fieldName);\r\n            }\r\n        }\r\n    }, [trigger, setFieldValue, updateAndGetDirtyState]);\r\n    const setInternalValue = Object(react[\"useCallback\"])((name, value, config) => {\r\n        !shouldUnregister &&\r\n            !isPrimitive(value) &&\r\n            set(shallowFieldsStateRef.current, name, Array.isArray(value) ? [...value] : Object.assign({}, value));\r\n        if (fieldsRef.current[name]) {\r\n            setFieldValue(name, value);\r\n            config.shouldDirty && updateAndGetDirtyState(name);\r\n            config.shouldValidate && trigger(name);\r\n        }\r\n        else if (!isPrimitive(value)) {\r\n            setInternalValues(name, value, config);\r\n            if (fieldArrayNamesRef.current.has(name)) {\r\n                const parentName = getFieldArrayParentName(name) || name;\r\n                set(fieldArrayDefaultValuesRef.current, name, value);\r\n                resetFieldArrayFunctionRef.current[parentName]({\r\n                    [parentName]: get(fieldArrayDefaultValuesRef.current, parentName),\r\n                });\r\n                if ((readFormStateRef.current.isDirty ||\r\n                    readFormStateRef.current.dirtyFields) &&\r\n                    config.shouldDirty) {\r\n                    set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                    updateFormState({\r\n                        isDirty: !deepEqual(Object.assign(Object.assign({}, getValues()), { [name]: value }), defaultValuesRef.current),\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\r\n    }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const renderWatchedInputs = (name) => {\r\n        let found = true;\r\n        if (!isEmptyObject(useWatchFieldsRef.current)) {\r\n            for (const key in useWatchFieldsRef.current) {\r\n                if (!name ||\r\n                    !useWatchFieldsRef.current[key].size ||\r\n                    useWatchFieldsRef.current[key].has(name) ||\r\n                    useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))) {\r\n                    useWatchRenderFunctionsRef.current[key]();\r\n                    found = false;\r\n                }\r\n            }\r\n        }\r\n        return found;\r\n    };\r\n    function setValue(name, value, config) {\r\n        setInternalValue(name, value, config || {});\r\n        isFieldWatched(name) && updateFormState();\r\n        renderWatchedInputs(name);\r\n    }\r\n    handleChangeRef.current = handleChangeRef.current\r\n        ? handleChangeRef.current\r\n        : async ({ type, target }) => {\r\n            let name = target.name;\r\n            const field = fieldsRef.current[name];\r\n            let error;\r\n            let isValid;\r\n            if (field) {\r\n                const isBlurEvent = type === EVENTS.BLUR;\r\n                const shouldSkipValidation = skipValidation(Object.assign({ isBlurEvent,\r\n                    isReValidateOnChange,\r\n                    isReValidateOnBlur, isTouched: !!get(formStateRef.current.touched, name), isSubmitted: formStateRef.current.isSubmitted }, modeRef.current));\r\n                let state = updateAndGetDirtyState(name, false);\r\n                let shouldRender = !isEmptyObject(state) ||\r\n                    (!isBlurEvent && isFieldWatched(name));\r\n                if (isBlurEvent &&\r\n                    !get(formStateRef.current.touched, name) &&\r\n                    readFormStateRef.current.touched) {\r\n                    set(formStateRef.current.touched, name, true);\r\n                    state = Object.assign(Object.assign({}, state), { touched: formStateRef.current.touched });\r\n                }\r\n                if (!shouldUnregister && isCheckBoxInput(target)) {\r\n                    set(shallowFieldsStateRef.current, name, getFieldValue(fieldsRef, name));\r\n                }\r\n                if (shouldSkipValidation) {\r\n                    !isBlurEvent && renderWatchedInputs(name);\r\n                    return ((!isEmptyObject(state) ||\r\n                        (shouldRender && isEmptyObject(state))) &&\r\n                        updateFormState(state));\r\n                }\r\n                updateIsValidating();\r\n                if (resolverRef.current) {\r\n                    const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n                    const previousFormIsValid = formStateRef.current.isValid;\r\n                    error = get(errors, name);\r\n                    if (isCheckBoxInput(target) &&\r\n                        !error &&\r\n                        resolverRef.current) {\r\n                        const parentNodeName = getFieldArrayParentName(name);\r\n                        const currentError = get(errors, parentNodeName, {});\r\n                        currentError.type &&\r\n                            currentError.message &&\r\n                            (error = currentError);\r\n                        if (parentNodeName &&\r\n                            (currentError ||\r\n                                get(formStateRef.current.errors, parentNodeName))) {\r\n                            name = parentNodeName;\r\n                        }\r\n                    }\r\n                    isValid = isEmptyObject(errors);\r\n                    previousFormIsValid !== isValid && (shouldRender = true);\r\n                }\r\n                else {\r\n                    error = (await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef))[name];\r\n                }\r\n                !isBlurEvent && renderWatchedInputs(name);\r\n                shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\r\n            }\r\n        };\r\n    function setFieldArrayDefaultValues(data) {\r\n        if (!shouldUnregister) {\r\n            let copy = cloneObject(data);\r\n            for (const value of fieldArrayNamesRef.current) {\r\n                if (isKey(value) && !copy[value]) {\r\n                    copy = Object.assign(Object.assign({}, copy), { [value]: [] });\r\n                }\r\n            }\r\n            return copy;\r\n        }\r\n        return data;\r\n    }\r\n    function getValues(payload) {\r\n        if (isString(payload)) {\r\n            return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\r\n        }\r\n        if (Array.isArray(payload)) {\r\n            const data = {};\r\n            for (const name of payload) {\r\n                set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\r\n            }\r\n            return data;\r\n        }\r\n        return setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister));\r\n    }\r\n    const validateResolver = Object(react[\"useCallback\"])(async (values = {}) => {\r\n        const newDefaultValues = isEmptyObject(fieldsRef.current)\r\n            ? defaultValuesRef.current\r\n            : {};\r\n        const { errors } = (await resolverRef.current(Object.assign(Object.assign(Object.assign({}, newDefaultValues), getValues()), values), contextRef.current, isValidateAllFieldCriteria)) || {};\r\n        const isValid = isEmptyObject(errors);\r\n        formStateRef.current.isValid !== isValid &&\r\n            updateFormState({\r\n                isValid,\r\n            });\r\n    }, [isValidateAllFieldCriteria]);\r\n    const removeFieldEventListener = Object(react[\"useCallback\"])((field, forceDelete) => {\r\n        findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete);\r\n        if (shouldUnregister) {\r\n            unset(validFieldsRef.current, field.ref.name);\r\n            unset(fieldsWithValidationRef.current, field.ref.name);\r\n        }\r\n    }, [shouldUnregister]);\r\n    const updateWatchedValue = Object(react[\"useCallback\"])((name) => {\r\n        if (isWatchAllRef.current) {\r\n            updateFormState();\r\n        }\r\n        else {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (watchField.startsWith(name)) {\r\n                    updateFormState();\r\n                    break;\r\n                }\r\n            }\r\n            renderWatchedInputs(name);\r\n        }\r\n    }, []);\r\n    const removeFieldEventListenerAndRef = Object(react[\"useCallback\"])((field, forceDelete) => {\r\n        if (field) {\r\n            removeFieldEventListener(field, forceDelete);\r\n            if (shouldUnregister && !compact(field.options || []).length) {\r\n                unset(formStateRef.current.errors, field.ref.name);\r\n                set(formStateRef.current.dirtyFields, field.ref.name, true);\r\n                updateFormState({\r\n                    isDirty: isFormDirty(),\r\n                });\r\n                readFormStateRef.current.isValid &&\r\n                    resolverRef.current &&\r\n                    validateResolver();\r\n                updateWatchedValue(field.ref.name);\r\n            }\r\n        }\r\n    }, [validateResolver, removeFieldEventListener]);\r\n    function clearErrors(name) {\r\n        name &&\r\n            (Array.isArray(name) ? name : [name]).forEach((inputName) => fieldsRef.current[inputName] && isKey(inputName)\r\n                ? delete formStateRef.current.errors[inputName]\r\n                : unset(formStateRef.current.errors, inputName));\r\n        updateFormState({\r\n            errors: name ? formStateRef.current.errors : {},\r\n        });\r\n    }\r\n    function setError(name, error) {\r\n        const ref = (fieldsRef.current[name] || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        updateFormState({\r\n            isValid: false,\r\n        });\r\n        error.shouldFocus && ref && ref.focus && ref.focus();\r\n    }\r\n    const watchInternal = Object(react[\"useCallback\"])((fieldNames, defaultValue, watchId) => {\r\n        const watchFields = watchId\r\n            ? useWatchFieldsRef.current[watchId]\r\n            : watchFieldsRef.current;\r\n        let fieldValues = getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, false, fieldNames);\r\n        if (isString(fieldNames)) {\r\n            const parentNodeName = getFieldArrayParentName(fieldNames) || fieldNames;\r\n            if (fieldArrayNamesRef.current.has(parentNodeName)) {\r\n                fieldValues = Object.assign(Object.assign({}, fieldArrayValuesRef.current), fieldValues);\r\n            }\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(get(defaultValuesRef.current, fieldNames))\r\n                ? defaultValue\r\n                : get(defaultValuesRef.current, fieldNames), true);\r\n        }\r\n        const combinedDefaultValues = isUndefined(defaultValue)\r\n            ? defaultValuesRef.current\r\n            : defaultValue;\r\n        if (Array.isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});\r\n        }\r\n        isWatchAllRef.current = isUndefined(watchId);\r\n        return transformToNestObject((!isEmptyObject(fieldValues) && fieldValues) ||\r\n            combinedDefaultValues);\r\n    }, []);\r\n    function watch(fieldNames, defaultValue) {\r\n        return watchInternal(fieldNames, defaultValue);\r\n    }\r\n    function unregister(name) {\r\n        for (const fieldName of Array.isArray(name) ? name : [name]) {\r\n            removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\r\n        }\r\n    }\r\n    function registerFieldRef(ref, options = {}) {\r\n        if (false) {}\r\n        const { name, type, value } = ref;\r\n        const fieldRefAndValidationOptions = Object.assign({ ref }, options);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n        const compareRef = (currentRef) => isWeb && (!isHTMLElement(ref) || currentRef === ref);\r\n        let field = fields[name];\r\n        let isEmptyDefaultValue = true;\r\n        let defaultValue;\r\n        if (field &&\r\n            (isRadioOrCheckbox\r\n                ? Array.isArray(field.options) &&\r\n                    compact(field.options).find((option) => {\r\n                        return value === option.ref.value && compareRef(option.ref);\r\n                    })\r\n                : compareRef(field.ref))) {\r\n            fields[name] = Object.assign(Object.assign({}, field), options);\r\n            return;\r\n        }\r\n        if (type) {\r\n            field = isRadioOrCheckbox\r\n                ? Object.assign({ options: [\r\n                        ...compact((field && field.options) || []),\r\n                        {\r\n                            ref,\r\n                        },\r\n                    ], ref: { type, name } }, options) : Object.assign({}, fieldRefAndValidationOptions);\r\n        }\r\n        else {\r\n            field = fieldRefAndValidationOptions;\r\n        }\r\n        fields[name] = field;\r\n        const isEmptyUnmountFields = isUndefined(get(shallowFieldsStateRef.current, name));\r\n        if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\r\n            defaultValue = get(isEmptyUnmountFields\r\n                ? defaultValuesRef.current\r\n                : shallowFieldsStateRef.current, name);\r\n            isEmptyDefaultValue = isUndefined(defaultValue);\r\n            if (!isEmptyDefaultValue && !isFieldArray) {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        if (!isEmptyObject(options)) {\r\n            set(fieldsWithValidationRef.current, name, true);\r\n            if (!isOnSubmit && readFormStateRef.current.isValid) {\r\n                validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then((error) => {\r\n                    const previousFormIsValid = formStateRef.current.isValid;\r\n                    isEmptyObject(error)\r\n                        ? set(validFieldsRef.current, name, true)\r\n                        : unset(validFieldsRef.current, name);\r\n                    previousFormIsValid !== isEmptyObject(error) && updateFormState();\r\n                });\r\n            }\r\n        }\r\n        if (shouldUnregister && !(isFieldArray && isEmptyDefaultValue)) {\r\n            !isFieldArray && unset(formStateRef.current.dirtyFields, name);\r\n        }\r\n        if (type) {\r\n            attachEventListeners(isRadioOrCheckbox && field.options\r\n                ? field.options[field.options.length - 1]\r\n                : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\r\n        }\r\n    }\r\n    function register(refOrRegisterOptions, options) {\r\n        if (!isWindowUndefined) {\r\n            if (isString(refOrRegisterOptions)) {\r\n                registerFieldRef({ name: refOrRegisterOptions }, options);\r\n            }\r\n            else if (isObject(refOrRegisterOptions) &&\r\n                'name' in refOrRegisterOptions) {\r\n                registerFieldRef(refOrRegisterOptions, options);\r\n            }\r\n            else {\r\n                return (ref) => ref && registerFieldRef(ref, refOrRegisterOptions);\r\n            }\r\n        }\r\n    }\r\n    const handleSubmit = Object(react[\"useCallback\"])((onValid, onInvalid) => async (e) => {\r\n        if (e && e.preventDefault) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors = {};\r\n        let fieldValues = setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, true));\r\n        readFormStateRef.current.isSubmitting &&\r\n            updateFormState({\r\n                isSubmitting: true,\r\n            });\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\r\n                formStateRef.current.errors = fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                for (const field of Object.values(fieldsRef.current)) {\r\n                    if (field) {\r\n                        const { name } = field.ref;\r\n                        const fieldError = await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\r\n                        if (fieldError[name]) {\r\n                            set(fieldErrors, name, fieldError[name]);\r\n                            unset(validFieldsRef.current, name);\r\n                        }\r\n                        else if (get(fieldsWithValidationRef.current, name)) {\r\n                            unset(formStateRef.current.errors, name);\r\n                            set(validFieldsRef.current, name, true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isEmptyObject(fieldErrors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => name in fieldsRef.current)) {\r\n                updateFormState({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);\r\n                onInvalid && (await onInvalid(formStateRef.current.errors, e));\r\n                shouldFocusError &&\r\n                    focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\r\n            }\r\n        }\r\n        finally {\r\n            formStateRef.current.isSubmitting = false;\r\n            updateFormState({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n            });\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria]);\r\n    const resetRefs = ({ errors, isDirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {\r\n        if (!isValid) {\r\n            validFieldsRef.current = {};\r\n            fieldsWithValidationRef.current = {};\r\n        }\r\n        fieldArrayDefaultValuesRef.current = {};\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        updateFormState({\r\n            submitCount: submitCount ? formStateRef.current.submitCount : 0,\r\n            isDirty: isDirty ? formStateRef.current.isDirty : false,\r\n            isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\r\n            isValid: isValid ? formStateRef.current.isValid : false,\r\n            dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\r\n            touched: touched ? formStateRef.current.touched : {},\r\n            errors: errors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    };\r\n    const reset = (values, omitResetState = {}) => {\r\n        if (isWeb) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field) {\r\n                    const { ref, options } = field;\r\n                    const inputRef = isRadioOrCheckboxFunction(ref) && Array.isArray(options)\r\n                        ? options[0].ref\r\n                        : ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        fieldsRef.current = {};\r\n        defaultValuesRef.current = Object.assign({}, (values || defaultValuesRef.current));\r\n        values && renderWatchedInputs('');\r\n        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());\r\n        shallowFieldsStateRef.current = shouldUnregister\r\n            ? {}\r\n            : cloneObject(values || defaultValuesRef.current);\r\n        resetRefs(omitResetState);\r\n    };\r\n    Object(react[\"useEffect\"])(() => {\r\n        resolver && readFormStateRef.current.isValid && validateResolver();\r\n        observerRef.current =\r\n            observerRef.current || !isWeb\r\n                ? observerRef.current\r\n                : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\r\n    }, [removeFieldEventListenerAndRef, defaultValuesRef.current]);\r\n    Object(react[\"useEffect\"])(() => () => {\r\n        observerRef.current && observerRef.current.disconnect();\r\n        isUnMount.current = true;\r\n        if (false) {}\r\n        Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));\r\n    }, []);\r\n    if (!resolver && readFormStateRef.current.isValid) {\r\n        formState.isValid =\r\n            deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\r\n                isEmptyObject(formStateRef.current.errors);\r\n    }\r\n    const commonProps = {\r\n        trigger,\r\n        setValue: Object(react[\"useCallback\"])(setValue, [setInternalValue, trigger]),\r\n        getValues: Object(react[\"useCallback\"])(getValues, []),\r\n        register: Object(react[\"useCallback\"])(register, [defaultValuesRef.current]),\r\n        unregister: Object(react[\"useCallback\"])(unregister, []),\r\n        formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (false) {}\r\n                    if (prop in obj) {\r\n                        readFormStateRef.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return undefined;\r\n                },\r\n            })\r\n            : formState,\r\n    };\r\n    const control = Object(react[\"useMemo\"])(() => (Object.assign({ isFormDirty,\r\n        updateWatchedValue,\r\n        shouldUnregister,\r\n        updateFormState,\r\n        removeFieldEventListener,\r\n        watchInternal, mode: modeRef.current, reValidateMode: {\r\n            isReValidateOnBlur,\r\n            isReValidateOnChange,\r\n        }, validateResolver: resolver ? validateResolver : undefined, fieldsRef,\r\n        resetFieldArrayFunctionRef,\r\n        useWatchFieldsRef,\r\n        useWatchRenderFunctionsRef,\r\n        fieldArrayDefaultValuesRef,\r\n        validFieldsRef,\r\n        fieldsWithValidationRef,\r\n        fieldArrayNamesRef,\r\n        readFormStateRef,\r\n        formStateRef,\r\n        defaultValuesRef,\r\n        shallowFieldsStateRef,\r\n        fieldArrayValuesRef }, commonProps)), [\r\n        defaultValuesRef.current,\r\n        updateWatchedValue,\r\n        shouldUnregister,\r\n        removeFieldEventListener,\r\n        watchInternal,\r\n    ]);\r\n    return Object.assign({ watch,\r\n        control,\r\n        handleSubmit, reset: Object(react[\"useCallback\"])(reset, []), clearErrors: Object(react[\"useCallback\"])(clearErrors, []), setError: Object(react[\"useCallback\"])(setError, []), errors: formState.errors }, commonProps);\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormContext = Object(react[\"createContext\"])(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => Object(react[\"useContext\"])(FormContext);\r\nconst FormProvider = (_a) => {\r\n    var { children } = _a, props = __rest(_a, [\"children\"]);\r\n    return (Object(react[\"createElement\"])(FormContext.Provider, { value: Object.assign({}, props) }, children));\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort((a, b) => a - b));\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    const temp = [data[indexB], data[indexA]];\r\n    data[indexA] = temp[0];\r\n    data[indexB] = temp[1];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\r\n}\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(Array.isArray(value) ? value : [value || undefined]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nvar fillBooleanArray = (value) => (Array.isArray(value) ? value : [value]).map((data) => {\r\n    if (isObject(data)) {\r\n        const object = {};\r\n        for (const key in data) {\r\n            object[key] = true;\r\n        }\r\n        return object;\r\n    }\r\n    return true;\r\n});\n\nconst mapIds = (values = [], keyName, skipWarn) => {\r\n    if (false) {}\r\n    return values.map((value) => (Object.assign({ [keyName]: value[keyName] || generateId() }, value)));\r\n};\r\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    if (false) {}\r\n    const focusIndexRef = Object(react[\"useRef\"])(-1);\r\n    const isUnMount = Object(react[\"useRef\"])(false);\r\n    const { isFormDirty, updateWatchedValue, resetFieldArrayFunctionRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, removeFieldEventListener, formStateRef, shallowFieldsStateRef, updateFormState, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, validateResolver, getValues, shouldUnregister, fieldArrayValuesRef, } = control || methods.control;\r\n    const getDefaultValues = (values) => get(shouldUnregister ? values : shallowFieldsStateRef.current, name, []);\r\n    const fieldArrayParentName = getFieldArrayParentName(name);\r\n    const memoizedDefaultValues = Object(react[\"useRef\"])([\r\n        ...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\r\n            ? getDefaultValues(fieldArrayDefaultValuesRef.current)\r\n            : getDefaultValues(defaultValuesRef.current)),\r\n    ]);\r\n    const [fields, setFields] = Object(react[\"useState\"])(mapIds(memoizedDefaultValues.current, keyName));\r\n    set(fieldArrayValuesRef.current, name, fields);\r\n    const omitKey = (fields) => fields.map((_a = {}) => {\r\n        var _b = keyName, omitted = _a[_b], rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\r\n        return rest;\r\n    });\r\n    fieldArrayNamesRef.current.add(name);\r\n    const getFieldArrayValue = Object(react[\"useCallback\"])(() => get(fieldArrayValuesRef.current, name, []), [name]);\r\n    const getCurrentFieldsValues = () => mapIds(get(getValues(), name, getFieldArrayValue()).map((item, index) => (Object.assign(Object.assign({}, getFieldArrayValue()[index]), item))), keyName, true);\r\n    fieldArrayNamesRef.current.add(name);\r\n    if (fieldArrayParentName &&\r\n        !get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\r\n        set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, cloneObject(get(defaultValuesRef.current, fieldArrayParentName)));\r\n    }\r\n    const setFieldAndValidState = (fieldsValues) => {\r\n        setFields(fieldsValues);\r\n        set(fieldArrayValuesRef.current, name, fieldsValues);\r\n        if (readFormStateRef.current.isValid && validateResolver) {\r\n            const values = getValues();\r\n            set(values, name, fieldsValues);\r\n            validateResolver(values);\r\n        }\r\n    };\r\n    const resetFields = () => {\r\n        for (const key in fieldsRef.current) {\r\n            if (isMatchFieldArrayName(key, name)) {\r\n                removeFieldEventListener(fieldsRef.current[key], true);\r\n                delete fieldsRef.current[key];\r\n            }\r\n        }\r\n    };\r\n    const cleanup = (ref) => !compact(get(ref, name, [])).length && unset(ref, name);\r\n    const updateDirtyFieldsWithDefaultValues = (updatedFieldArrayValues) => {\r\n        if (updatedFieldArrayValues) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n        }\r\n    };\r\n    const batchStateUpdate = (method, args, updatedFieldValues, updatedFormValues = [], shouldSet = true, shouldUpdateValid = false) => {\r\n        if (get(shallowFieldsStateRef.current, name)) {\r\n            const output = method(get(shallowFieldsStateRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(shallowFieldsStateRef.current, name, output);\r\n        }\r\n        if (get(fieldArrayDefaultValuesRef.current, name)) {\r\n            const output = method(get(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\r\n        }\r\n        if (Array.isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touched &&\r\n            get(formStateRef.current.touched, name)) {\r\n            const output = method(get(formStateRef.current.touched, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.touched, name, output);\r\n            cleanup(formStateRef.current.touched);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFormValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n            updateDirtyFieldsWithDefaultValues(updatedFieldValues);\r\n            cleanup(formStateRef.current.dirtyFields);\r\n        }\r\n        if (shouldUpdateValid &&\r\n            readFormStateRef.current.isValid &&\r\n            !validateResolver) {\r\n            set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\r\n            cleanup(validFieldsRef.current);\r\n            set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\r\n            cleanup(fieldsWithValidationRef.current);\r\n        }\r\n        if (!isUnMount.current && readFormStateRef.current.isDirty) {\r\n            updateFormState({\r\n                isDirty: isFormDirty(name, omitKey(updatedFormValues)),\r\n            });\r\n        }\r\n    };\r\n    const append = (value, shouldFocus = true) => {\r\n        const appendValue = Array.isArray(value) ? value : [value];\r\n        const updateFormValues = [\r\n            ...getCurrentFieldsValues(),\r\n            ...mapIds(appendValue, keyName),\r\n        ];\r\n        setFieldAndValidState(updateFormValues);\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            updateDirtyFieldsWithDefaultValues(updateFormValues);\r\n            updateFormState({\r\n                isDirty: true,\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            });\r\n        }\r\n        !shouldUnregister &&\r\n            set(shallowFieldsStateRef.current, name, [\r\n                ...(get(shallowFieldsStateRef.current, name) || []),\r\n                ...cloneObject(appendValue),\r\n            ]);\r\n        focusIndexRef.current = shouldFocus\r\n            ? get(fieldArrayValuesRef.current, name).length - 1\r\n            : -1;\r\n    };\r\n    const prepend$1 = (value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), mapIds(Array.isArray(value) ? value : [value], keyName));\r\n        setFieldAndValidState(updatedFieldArrayValues);\r\n        resetFields();\r\n        batchStateUpdate(prepend, {\r\n            argA: emptyArray,\r\n            argC: fillBooleanArray(value),\r\n        }, updatedFieldArrayValues);\r\n        focusIndexRef.current = shouldFocus ? 0 : -1;\r\n    };\r\n    const remove = (index) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        const updatedFieldValues = removeArrayAt(fieldValues, index);\r\n        setFieldAndValidState(updatedFieldValues);\r\n        resetFields();\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n            argC: index,\r\n        }, updatedFieldValues, removeArrayAt(fieldValues, index), true, true);\r\n    };\r\n    const insert$1 = (index, value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        const fieldValues = getCurrentFieldsValues();\r\n        const updatedFieldArrayValues = insert(fieldValues, index, mapIds(Array.isArray(value) ? value : [value], keyName));\r\n        setFieldAndValidState(updatedFieldArrayValues);\r\n        resetFields();\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: emptyArray,\r\n            argC: index,\r\n            argD: fillBooleanArray(value),\r\n        }, updatedFieldArrayValues, insert(fieldValues, index));\r\n        focusIndexRef.current = shouldFocus ? index : -1;\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        resetFields();\r\n        setFieldAndValidState([...fieldValues]);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n            argC: indexA,\r\n            argD: indexB,\r\n        }, undefined, fieldValues, false);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        resetFields();\r\n        setFieldAndValidState([...fieldValues]);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n            argC: from,\r\n            argD: to,\r\n        }, undefined, fieldValues, false);\r\n    };\r\n    Object(react[\"useEffect\"])(() => {\r\n        if (false) {}\r\n        const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\r\n        if (defaultValues && fields.length < defaultValues.length) {\r\n            set(fieldArrayDefaultValuesRef.current, name, defaultValues.slice(1));\r\n        }\r\n        updateWatchedValue(name);\r\n        if (focusIndexRef.current > -1) {\r\n            for (const key in fieldsRef.current) {\r\n                const field = fieldsRef.current[key];\r\n                if (key.startsWith(`${name}[${focusIndexRef.current}]`) &&\r\n                    field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        focusIndexRef.current = -1;\r\n    }, [fields, name]);\r\n    Object(react[\"useEffect\"])(() => {\r\n        const resetFunctions = resetFieldArrayFunctionRef.current;\r\n        const fieldArrayNames = fieldArrayNamesRef.current;\r\n        if (!getFieldArrayParentName(name)) {\r\n            resetFunctions[name] = (data) => {\r\n                resetFields();\r\n                !data && unset(fieldArrayDefaultValuesRef.current, name);\r\n                unset(shallowFieldsStateRef.current, name);\r\n                memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\r\n                if (!isUnMount.current) {\r\n                    setFields(mapIds(memoizedDefaultValues.current, keyName));\r\n                }\r\n            };\r\n        }\r\n        return () => {\r\n            isUnMount.current = true;\r\n            shouldUnregister && remove();\r\n            resetFields();\r\n            delete resetFunctions[name];\r\n            unset(fieldArrayValuesRef.current, name);\r\n            fieldArrayNames.delete(name);\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: Object(react[\"useCallback\"])(swap, [name]),\r\n        move: Object(react[\"useCallback\"])(move, [name]),\r\n        prepend: Object(react[\"useCallback\"])(prepend$1, [name]),\r\n        append: Object(react[\"useCallback\"])(append, [name]),\r\n        remove: Object(react[\"useCallback\"])(remove, [name]),\r\n        insert: Object(react[\"useCallback\"])(insert$1, [name]),\r\n        fields,\r\n    };\r\n};\n\nvar getInputValue = (event) => isPrimitive(event) ||\r\n    !isObject(event.target) ||\r\n    (isObject(event.target) && !event.type)\r\n    ? event\r\n    : isUndefined(event.target.value)\r\n        ? event.target.checked\r\n        : event.target.value;\n\nfunction useController({ name, rules, defaultValue, control, onFocus, }) {\r\n    const methods = useFormContext();\r\n    if (false) {}\r\n    const { defaultValuesRef, setValue, register, unregister, trigger, mode, reValidateMode: { isReValidateOnBlur, isReValidateOnChange }, formState, formStateRef: { current: { isSubmitted, touched, errors }, }, updateFormState, readFormStateRef, fieldsRef, fieldArrayNamesRef, shallowFieldsStateRef, } = control || methods.control;\r\n    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    const getInitialValue = () => !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray\r\n        ? get(shallowFieldsStateRef.current, name)\r\n        : isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue;\r\n    const [value, setInputStateValue] = Object(react[\"useState\"])(getInitialValue());\r\n    const valueRef = Object(react[\"useRef\"])(value);\r\n    const ref = Object(react[\"useRef\"])({\r\n        focus: () => null,\r\n    });\r\n    const onFocusRef = Object(react[\"useRef\"])(onFocus ||\r\n        (() => {\r\n            if (isFunction(ref.current.focus)) {\r\n                ref.current.focus();\r\n            }\r\n            if (false) {}\r\n        }));\r\n    const shouldValidate = Object(react[\"useCallback\"])((isBlurEvent) => !skipValidation(Object.assign({ isBlurEvent,\r\n        isReValidateOnBlur,\r\n        isReValidateOnChange,\r\n        isSubmitted, isTouched: !!get(touched, name) }, mode)), [\r\n        isReValidateOnBlur,\r\n        isReValidateOnChange,\r\n        isSubmitted,\r\n        touched,\r\n        name,\r\n        mode,\r\n    ]);\r\n    const commonTask = Object(react[\"useCallback\"])(([event]) => {\r\n        const data = getInputValue(event);\r\n        setInputStateValue(data);\r\n        valueRef.current = data;\r\n        return data;\r\n    }, []);\r\n    const registerField = Object(react[\"useCallback\"])((shouldUpdateValue) => {\r\n        if (false) {}\r\n        if (fieldsRef.current[name]) {\r\n            fieldsRef.current[name] = Object.assign({ ref: fieldsRef.current[name].ref }, rules);\r\n        }\r\n        else {\r\n            register(Object.defineProperties({\r\n                name,\r\n                focus: onFocusRef.current,\r\n            }, {\r\n                value: {\r\n                    set(data) {\r\n                        setInputStateValue(data);\r\n                        valueRef.current = data;\r\n                    },\r\n                    get() {\r\n                        return valueRef.current;\r\n                    },\r\n                },\r\n            }), rules);\r\n            shouldUpdateValue = isUndefined(get(defaultValuesRef.current, name));\r\n        }\r\n        shouldUpdateValue &&\r\n            isNotFieldArray &&\r\n            setInputStateValue(getInitialValue());\r\n    }, [rules, name, register]);\r\n    Object(react[\"useEffect\"])(() => () => unregister(name), [name]);\r\n    Object(react[\"useEffect\"])(() => {\r\n        if (false) {}\r\n        registerField();\r\n    }, [registerField]);\r\n    Object(react[\"useEffect\"])(() => {\r\n        !fieldsRef.current[name] && registerField(true);\r\n    });\r\n    const onBlur = Object(react[\"useCallback\"])(() => {\r\n        if (readFormStateRef.current.touched && !get(touched, name)) {\r\n            set(touched, name, true);\r\n            updateFormState({\r\n                touched,\r\n            });\r\n        }\r\n        shouldValidate(true) && trigger(name);\r\n    }, [name, updateFormState, shouldValidate, trigger, readFormStateRef]);\r\n    const onChange = Object(react[\"useCallback\"])((...event) => setValue(name, commonTask(event), {\r\n        shouldValidate: shouldValidate(),\r\n        shouldDirty: true,\r\n    }), [setValue, name, shouldValidate]);\r\n    return {\r\n        field: {\r\n            onChange,\r\n            onBlur,\r\n            name,\r\n            value,\r\n            ref,\r\n        },\r\n        meta: Object.defineProperties({\r\n            invalid: !!get(errors, name),\r\n        }, {\r\n            isDirty: {\r\n                get() {\r\n                    return !!get(formState.dirtyFields, name);\r\n                },\r\n            },\r\n            isTouched: {\r\n                get() {\r\n                    return !!get(formState.touched, name);\r\n                },\r\n            },\r\n        }),\r\n    };\r\n}\n\nfunction useWatch({ control, name, defaultValue, }) {\r\n    const methods = useFormContext();\r\n    if (false) {}\r\n    const { useWatchFieldsRef, useWatchRenderFunctionsRef, watchInternal, defaultValuesRef, } = control || methods.control;\r\n    const updateValue = Object(react[\"useState\"])()[1];\r\n    const idRef = Object(react[\"useRef\"])();\r\n    const defaultValueRef = Object(react[\"useRef\"])(defaultValue);\r\n    Object(react[\"useEffect\"])(() => {\r\n        if (false) {}\r\n        const id = (idRef.current = generateId());\r\n        const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\r\n        const watchFieldsHook = useWatchFieldsRef.current;\r\n        watchFieldsHook[id] = new Set();\r\n        watchFieldsHookRender[id] = () => updateValue({});\r\n        watchInternal(name, defaultValueRef.current, id);\r\n        return () => {\r\n            delete watchFieldsHook[id];\r\n            delete watchFieldsHookRender[id];\r\n        };\r\n    }, [\r\n        name,\r\n        useWatchRenderFunctionsRef,\r\n        useWatchFieldsRef,\r\n        watchInternal,\r\n        defaultValueRef,\r\n    ]);\r\n    return idRef.current\r\n        ? watchInternal(name, defaultValueRef.current, idRef.current)\r\n        : isUndefined(defaultValue)\r\n            ? isString(name)\r\n                ? get(defaultValuesRef.current, name)\r\n                : Array.isArray(name)\r\n                    ? name.reduce((previous, inputName) => (Object.assign(Object.assign({}, previous), { [inputName]: get(defaultValuesRef.current, inputName) })), {})\r\n                    : defaultValuesRef.current\r\n            : defaultValue;\r\n}\n\nconst Controller = (props) => {\r\n    const { rules, as, render, defaultValue, control, onFocus } = props, rest = __rest(props, [\"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\r\n    const { field, meta } = useController(props);\r\n    const componentProps = Object.assign(Object.assign({}, rest), field);\r\n    return as\r\n        ? Object(react[\"isValidElement\"])(as)\r\n            ? Object(react[\"cloneElement\"])(as, componentProps)\r\n            : Object(react[\"createElement\"])(as, componentProps)\r\n        : render\r\n            ? render(field, meta)\r\n            : null;\r\n};\n\n\n//# sourceMappingURL=index.esm.js.map\n\n// EXTERNAL MODULE: ./services/user.js\nvar user = __webpack_require__(\"LzO8\");\n\n// EXTERNAL MODULE: ./components/verifyAccount/verifyAccount.js\nvar verifyAccount = __webpack_require__(\"CGRP\");\n\n// EXTERNAL MODULE: ./components/popUpMessage/popUpMessage.js + 33 modules\nvar popUpMessage = __webpack_require__(\"GBzw\");\n\n// EXTERNAL MODULE: ./context/apiIsLoadingContext.js\nvar apiIsLoadingContext = __webpack_require__(\"BIE6\");\n\n// EXTERNAL MODULE: ./node_modules/react-phone-input-2/lib/material.css\nvar material = __webpack_require__(\"Bec1\");\n\n// CONCATENATED MODULE: ./pages/singup.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar singup_singup = function singup() {\n  var _React$useContext = react_default.a.useContext(languageContext[\"a\" /* default */]),\n      _React$useContext2 = Object(slicedToArray[\"a\" /* default */])(_React$useContext, 2),\n      language = _React$useContext2[0],\n      setLanguage = _React$useContext2[1];\n\n  var _React$useState = react_default.a.useState(\"email\"),\n      _React$useState2 = Object(slicedToArray[\"a\" /* default */])(_React$useState, 2),\n      showEmailOrTel = _React$useState2[0],\n      setShowEmailOrTel = _React$useState2[1];\n\n  var _React$useState3 = react_default.a.useState(\"1998-01-27T23:00:00.000Z\"),\n      _React$useState4 = Object(slicedToArray[\"a\" /* default */])(_React$useState3, 2),\n      birthDay = _React$useState4[0],\n      setBirthDay = _React$useState4[1];\n\n  var _React$useState5 = react_default.a.useState({\n    state: false,\n    userid: \"\"\n  }),\n      _React$useState6 = Object(slicedToArray[\"a\" /* default */])(_React$useState5, 2),\n      openVerifieAccountModal = _React$useState6[0],\n      setOpenVerifieAccountModal = _React$useState6[1];\n\n  var _useForm = useForm(),\n      register = _useForm.register,\n      handleSubmit = _useForm.handleSubmit,\n      errors = _useForm.errors,\n      watch = _useForm.watch;\n\n  var password = react_default.a.useRef({});\n  password.current = watch(\"password\", \"\");\n\n  var _React$useState7 = react_default.a.useState({\n    state: false,\n    text: \"\"\n  }),\n      _React$useState8 = Object(slicedToArray[\"a\" /* default */])(_React$useState7, 2),\n      errorMessage = _React$useState8[0],\n      setErrorMessage = _React$useState8[1]; // when state true show  pop up \n\n\n  var _React$useContext3 = react_default.a.useContext(apiIsLoadingContext[\"a\" /* default */]),\n      _React$useContext4 = Object(slicedToArray[\"a\" /* default */])(_React$useContext3, 2),\n      isLoading = _React$useContext4[0],\n      setIsLoading = _React$useContext4[1];\n\n  var onChangeHandlerRegisterPhone = function onChangeHandlerRegisterPhone(data, country) {\n    document.querySelector(\"#telId\").value = JSON.stringify({\n      \"dialCode\": country.dialCode,\n      'tel': data\n    });\n  };\n\n  var switchTo = function switchTo() {\n    setShowEmailOrTel(function (e) {\n      if (e == \"tel\") {\n        return \"email\";\n      } else {\n        return \"tel\";\n      }\n    });\n  };\n\n  var setBirthDayfn = function setBirthDayfn(date) {\n    setBirthDay(date);\n    document.querySelector(\"#ageId\").value = date;\n  };\n\n  var onSubmit = function onSubmit(data) {\n    setIsLoading(true);\n    Object(user[\"f\" /* Register */])(data).then(function (res) {\n      if (res.data == undefined) {\n        setIsLoading(false);\n      } else if (res.data.state == false) {\n        setErrorMessage({\n          state: true,\n          text: res.data.message\n        });\n        setIsLoading(false);\n      } else {\n        setOpenVerifieAccountModal({\n          state: true,\n          userid: res.data.userid\n        });\n        setIsLoading(false);\n      }\n    })[\"catch\"](function (error) {\n      setErrorMessage({\n        state: true,\n        text: error.message\n      });\n      setIsLoading(false);\n    });\n  };\n\n  var closePopUp = function closePopUp() {\n    setErrorMessage({\n      state: false,\n      text: \"\"\n    });\n  };\n\n  return /*#__PURE__*/Object(jsx_runtime[\"jsxs\"])(\"div\", {\n    className: singup_module_default.a.pageContainer,\n    children: [errorMessage.state == true && /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(popUpMessage[\"a\" /* default */], {\n      fnclose: closePopUp,\n      openPopUp: errorMessage\n    }), openVerifieAccountModal.state && /*#__PURE__*/Object(jsx_runtime[\"jsxs\"])(jsx_runtime[\"Fragment\"], {\n      children: [/*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"div\", {\n        className: singup_module_default.a.close,\n        onClick: function onClick() {\n          return setOpenVerifieAccountModal({\n            state: false,\n            userid: \"\"\n          });\n        }\n      }), /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(verifyAccount[\"a\" /* default */], {\n        userId: openVerifieAccountModal.userid\n      })]\n    }), /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"div\", {\n      className: singup_module_default.a.formContainer,\n      children: /*#__PURE__*/Object(jsx_runtime[\"jsxs\"])(\"form\", {\n        onSubmit: handleSubmit(onSubmit),\n        children: [/*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"input\", {\n          name: \"age\",\n          id: \"ageId\",\n          defaultValue: \"1998-01-27T23:00:00.000Z\",\n          ref: register({\n            required: \"Required\"\n          }),\n          style: {\n            position: \"absolute\",\n            opacity: 0,\n            pointerEvents: \"none\"\n          }\n        }), /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"div\", {\n          className: singup_module_default.a.Header,\n          children: /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"h1\", {\n            children: \"Sing up For NOZZLA\"\n          })\n        }), /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"div\", {\n          className: singup_module_default.a.descriptionHeader,\n          children: /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"h3\", {\n            children: language.createaprofilefollowotheraccountstalkaboutyourownexperienceandmore\n          })\n        }), /*#__PURE__*/Object(jsx_runtime[\"jsxs\"])(\"div\", {\n          className: singup_module_default.a.inputContainer,\n          children: [/*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"input\", {\n            className: singup_module_default.a.input,\n            ref: register,\n            name: \"userName\",\n            required: true\n          }), /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"label\", {\n            children: /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"span\", {\n              children: language.username\n            })\n          })]\n        }), /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"div\", {\n          className: singup_module_default.a.switchContainer,\n          children: /*#__PURE__*/Object(jsx_runtime[\"jsxs\"])(\"p\", {\n            onClick: function onClick() {\n              return switchTo();\n            },\n            children: [\"siwtch to \", showEmailOrTel == \"tel\" ? \"email\" : \"tel\"]\n          })\n        }), /*#__PURE__*/Object(jsx_runtime[\"jsxs\"])(\"div\", {\n          className: \"\".concat(singup_module_default.a.inputContainerTelOrEmail),\n          children: [/*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"input\", {\n            type: \"text\",\n            name: \"tel\",\n            style: {\n              position: 'absolute',\n              pointerEvents: \"none\",\n              opacity: 0\n            }\n          }), showEmailOrTel == \"tel\" && /*#__PURE__*/Object(jsx_runtime[\"jsxs\"])(jsx_runtime[\"Fragment\"], {\n            children: [/*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"input\", {\n              name: \"tel\",\n              id: \"telId\",\n              ref: register({\n                required: \"Required\"\n              }),\n              style: {\n                position: \"absolute\",\n                opacity: 0,\n                pointerEvents: \"none\"\n              }\n            }), /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(lib_default.a, {\n              name: \"tel\",\n              specialLabel: language.phone,\n              country: 'tn',\n              inputProps: {\n                name: 'phone',\n                required: true,\n                autoFocus: true\n              },\n              onChange: function onChange(e, country) {\n                return onChangeHandlerRegisterPhone(e, country);\n              }\n            })]\n          }), showEmailOrTel == \"email\" && /*#__PURE__*/Object(jsx_runtime[\"jsxs\"])(\"div\", {\n            className: singup_module_default.a.inputContainer,\n            children: [/*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"input\", {\n              name: \"email\",\n              ref: register({\n                required: \"Required\",\n                pattern: {\n                  value: /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,\n                  message: \"invalid email address\"\n                }\n              }),\n              className: singup_module_default.a.input,\n              required: true\n            }), /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"label\", {\n              children: /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"span\", {\n                children: \"email\"\n              })\n            })]\n          })]\n        }), errors.tel && /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"div\", {\n          className: singup_module_default.a.error,\n          children: /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"p\", {\n            children: \"tel is required\"\n          })\n        }), errors.email && /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"div\", {\n          className: singup_module_default.a.error,\n          children: /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"p\", {\n            children: \"email is incorect\"\n          })\n        }), /*#__PURE__*/Object(jsx_runtime[\"jsxs\"])(\"div\", {\n          className: singup_module_default.a.inputContainer,\n          children: [/*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"input\", {\n            name: \"password\",\n            type: \"password\",\n            ref: register({\n              required: \"password required\",\n              minLength: 8\n            }),\n            className: singup_module_default.a.input,\n            required: true\n          }), /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"label\", {\n            children: /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"span\", {\n              children: language.password\n            })\n          })]\n        }), errors.password && /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"div\", {\n          className: singup_module_default.a.error,\n          children: /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"p\", {\n            children: \"password length must be 8 at least\"\n          })\n        }), /*#__PURE__*/Object(jsx_runtime[\"jsxs\"])(\"div\", {\n          className: singup_module_default.a.inputContainer,\n          children: [/*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"input\", {\n            name: \"confirmPassword\",\n            type: \"password\",\n            ref: register({\n              validate: function validate(value) {\n                return value === password.current || \"The passwords do not match\";\n              }\n            }),\n            className: singup_module_default.a.input,\n            required: true\n          }), /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"label\", {\n            children: /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"span\", {\n              children: language.confirmpassword\n            })\n          })]\n        }), errors.confirmPassword && /*#__PURE__*/Object(jsx_runtime[\"jsxs\"])(\"div\", {\n          className: singup_module_default.a.error,\n          children: [\" \", /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"p\", {\n            children: errors.confirmPassword.message\n          })]\n        }), /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"div\", {\n          className: \"\".concat(singup_module_default.a.inputContainer, \" \").concat(singup_module_default.a.birthDay),\n          children: /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(react_rainbow_components[\"DatePicker\"], {\n            value: birthDay,\n            onChange: function onChange(value) {\n              return setBirthDayfn(value);\n            },\n            label: \"birth Day\",\n            formatStyle: \"large\",\n            locale: language.age\n          })\n        }), errors.age && /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"div\", {\n          className: singup_module_default.a.error,\n          children: /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"p\", {\n            children: \"age is required\"\n          })\n        }), /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"div\", {\n          className: singup_module_default.a.btnContainer,\n          children: /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"button\", {\n            children: language.signin\n          })\n        }), /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"div\", {\n          className: singup_module_default.a.messageToCreateAccounOrForgetPassword,\n          children: /*#__PURE__*/Object(jsx_runtime[\"jsxs\"])(\"p\", {\n            className: singup_module_default.a.message,\n            children: [language.AlreadyHaveAccount, \" \", /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(link_default.a, {\n              href: \"/signin\",\n              children: /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"span\", {\n                className: singup_module_default.a.clickHere,\n                children: language.signin\n              })\n            }), /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"br\", {}), \" \", /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(link_default.a, {\n              href: \"/forgetPassword\",\n              children: /*#__PURE__*/Object(jsx_runtime[\"jsx\"])(\"span\", {\n                className: singup_module_default.a.forgetPassword,\n                children: language.ForgotPassword\n              })\n            })]\n          })\n        })]\n      })\n    })]\n  });\n};\n\n/* harmony default export */ var pages_singup = __webpack_exports__[\"default\"] = (singup_singup);\n\n/***/ }),\n\n/***/ \"xp7T\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\n      (window.__NEXT_P = window.__NEXT_P || []).push([\n        \"/singup\",\n        function () {\n          return __webpack_require__(\"l50k\");\n        }\n      ]);\n    \n\n/***/ })\n\n},[[\"xp7T\",0,2,11,8,6,7,1,3,5,4,9,10]]]);","inputSourceMap":{"version":3,"sources":["F:\\AHKI\\node_modules\\next\\dist\\build\\webpack\\plugins\\mini-css-extract-plugin\\src\\loader.js??ref--5-oneOf-3-0!F:\\AHKI\\node_modules\\next\\dist\\compiled\\css-loader\\cjs.js??ref--5-oneOf-3-1!F:\\AHKI\\node_modules\\next\\dist\\compiled\\postcss-loader\\cjs.js??ref--5-oneOf-3-2!F:\\AHKI\\node_modules\\next\\dist\\compiled\\resolve-url-loader\\index.js??ref--5-oneOf-3-3!F:\\AHKI\\node_modules\\next\\dist\\compiled\\sass-loader\\cjs.js??ref--5-oneOf-3-4!F:\\AHKI\\styles\\singup.module.scss","F:\\AHKI\\node_modules\\react-hook-form\\dist\\index.esm.js","F:\\AHKI\\node_modules\\next\\dist\\build\\webpack\\loaders\\next-babel-loader.js??ref--4!F:\\AHKI\\pages\\singup.js","F:\\AHKI\\node_modules\\next\\dist\\build\\webpack\\loaders\\next-client-pages-loader.js?page=%2Fsingup&absolutePagePath=private-next-pages%2Fsingup.js!"],"names":[],"mappings":";;;;;;AAAA;AACA,kBAAkB,unB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDgI;;AAElJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,WAAW;AACzB,WAAW,QAAQ;;AAEnB;;AAEA;;AAEA;;AAEA,wDAAwD,OAAO;;AAE/D;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO,QAAQ,EAAE;AACxC,oBAAoB;AACpB;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO,kBAAkB,gDAAgD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY,OAAO,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,+BAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,iFAAiF;AACjF;AACA;AACA,wDAAwD;AACxD,kDAAkD;AAClD,0EAA0E,wBAAwB,cAAc;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,0DAA0D;AACtF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8CAA8C,+BAAc;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,kBAAkB,sCAAsC,+DAA+D,KAAK,0BAA0B,GAAG;;AAE7L,iEAAiE,YAAY,QAAQ,yEAAyE;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe;AACf;AACA;AACA,yCAAyC;AACzC,uEAAuE;AACvE,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA,yCAAyC;AACzC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,2HAA2H;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+DAA+D,WAAW;AAC1E;;AAEA,qDAAqD,OAAO;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA,kBAAkB,kHAAkH,mEAAmE,KAAK;AAC5M,sBAAsB,uBAAM,GAAG;AAC/B,uCAAuC,uBAAM,GAAG;AAChD,gCAAgC,uBAAM,GAAG;AACzC,2BAA2B,uBAAM;AACjC,8BAA8B,uBAAM,GAAG;AACvC,uCAAuC,uBAAM,GAAG;AAChD,oCAAoC,uBAAM,GAAG;AAC7C,2BAA2B,uBAAM,GAAG;AACpC,6BAA6B,uBAAM;AACnC,sBAAsB,uBAAM;AAC5B,0BAA0B,uBAAM;AAChC,4BAA4B,uBAAM;AAClC,kCAAkC,uBAAM,GAAG;AAC3C,uCAAuC,uBAAM,GAAG;AAChD,uBAAuB,uBAAM;AAC7B,wBAAwB,uBAAM;AAC9B,+BAA+B,uBAAM;AACrC,oBAAoB,uBAAM;AAC1B,WAAW,wBAAwB;AACnC;AACA,sCAAsC,yBAAQ;AAC9C;AACA;AACA,uBAAuB;AACvB;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,kBAAkB;AAClB,KAAK;AACL,6BAA6B,uBAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB,uBAAM;AAC/B,wBAAwB,uBAAM;AAC9B,WAAW,kEAAkE,GAAG,uBAAM;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAAW,YAAY;AACnD;AACA,iEAAiE;AACjE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,oCAAoC,4BAAW,+CAA+C;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,kCAAkC,qBAAqB,KAAK,KAAK,sBAAsB;AAC/J;AACA,KAAK;AACL,0BAA0B,4BAAW;AACrC,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,wBAAwB,4BAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mCAAmC,4BAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,4BAAW;AACzC,YAAY,KAAqC,EAAE,EAK1C;AACT;AACA;AACA;AACA,KAAK;AACL,8CAA8C,4BAAW;AACzD,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mGAAmG;AACnG;AACA;AACA,KAAK;AACL,oBAAoB,4BAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL,8BAA8B,4BAAW,gBAAgB,8BAA8B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,6BAA6B,4BAAW;AACxC;AACA;AACA,yGAAyG;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,0EAA0E,iBAAiB,gBAAgB;AAC3G,qBAAqB;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA,6IAA6I;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW,wCAAwC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,UAAU,cAAc;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4BAAW,mBAAmB;AAC3D;AACA;AACA;AACA,eAAe,SAAS,0EAA0E;AAClG;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,qCAAqC,4BAAW;AAChD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,+BAA+B,4BAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,2CAA2C,4BAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,SAAS;AACT;AACA;AACA,kDAAkD;AAClD,6EAA6E,WAAW,MAAM;AAC9F;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,4BAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,cAAc,mFAAmF,MAAM;AAC/L;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,YAAY,KAAqC,EAAE,EAU1C;AACT,eAAe,oBAAoB;AACnC,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,yBAAyB;AACzB,6BAA6B,aAAa,EAAE,6BAA6B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6BAA6B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4BAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL,wBAAwB,4EAA4E;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E,gEAAgE;AAChE,6DAA6D;AAC7D;AACA;AACA,SAAS;AACT;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0BAAS;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,0BAAS;AACb;AACA;AACA,YAAY,KAAqC,EAAE,EAE1C;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAAW;AAC7B,mBAAmB,4BAAW;AAC9B,kBAAkB,4BAAW;AAC7B,oBAAoB,4BAAW;AAC/B;AACA;AACA;AACA,wBAAwB,KAAqC,EAAE,EAI1C;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,oBAAoB,wBAAO,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,6BAA6B,4BAAW,0BAA0B,4BAAW,6BAA6B,4BAAW,0CAA0C;AAC/J;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,8BAAa;AACjC;AACA,6BAA6B,2BAAU;AACvC;AACA,SAAS,WAAW;AACpB,YAAY,8BAAa,wBAAwB,wBAAwB,UAAU;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,QAAQ,KAAqC,EAAE,EAe1C;AACL,iDAAiD,4CAA4C;AAC7F;AACA,wBAAwB,iCAAiC;AACzD;AACA,QAAQ,KAAqC,EAAE,EAI1C;AACL,0BAA0B,uBAAM;AAChC,sBAAsB,uBAAM;AAC5B,WAAW,2VAA2V;AACtW;AACA;AACA,kCAAkC,uBAAM;AACxC;AACA;AACA;AACA;AACA,gCAAgC,yBAAQ;AACxC;AACA,mDAAmD;AACnD;AACA;AACA,KAAK;AACL;AACA,+BAA+B,4BAAW;AAC1C,iJAAiJ;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,IAAI,0BAAS;AACb,YAAY,KAAqC,EAAE,EAI1C;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK,GAAG,sBAAsB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,0BAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,4BAAW;AACzB,cAAc,4BAAW;AACzB,iBAAiB,4BAAW;AAC5B,gBAAgB,4BAAW;AAC3B,gBAAgB,4BAAW;AAC3B,gBAAgB,4BAAW;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,+CAA+C;AACvE;AACA,QAAQ,KAAqC,EAAE,EAI1C;AACL,WAAW,mFAAmF,2CAA2C,4BAA4B,WAAW,+BAA+B,GAAG,4FAA4F;AAC9S;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yBAAQ;AAChD,qBAAqB,uBAAM;AAC3B,gBAAgB,uBAAM;AACtB;AACA,KAAK;AACL,uBAAuB,uBAAM;AAC7B;AACA;AACA;AACA;AACA,gBAAgB,KAAqC,EAAE,EAI1C;AACb,SAAS;AACT,2BAA2B,4BAAW,iDAAiD;AACvF;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAAW;AAClC;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,4BAAW;AACrC,YAAY,KAAqC,EAAE,EAI1C;AACT;AACA,qDAAqD,mCAAmC;AACxF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,0BAAS;AACb,IAAI,0BAAS;AACb,YAAY,KAAqC,EAAE,EAO1C;AACT;AACA,KAAK;AACL,IAAI,0BAAS;AACb;AACA,KAAK;AACL,mBAAmB,4BAAW;AAC9B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL,qBAAqB,4BAAW;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AA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","file":"x","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"pageContainer\":\"singup_pageContainer__34S6Y\",\"formContainer\":\"singup_formContainer__1YGeD\",\"inputContainer\":\"singup_inputContainer__2Gn17\",\"Header\":\"singup_Header__10-IF\",\"descriptionHeader\":\"singup_descriptionHeader__jc8pI\",\"btnContainer\":\"singup_btnContainer__2Ex20\",\"messageToCreateAccounOrForgetPassword\":\"singup_messageToCreateAccounOrForgetPassword__2hsIQ\",\"message\":\"singup_message__2qTl8\",\"clickHere\":\"singup_clickHere__kol6t\",\"forgetPassword\":\"singup_forgetPassword__1icLy\",\"birthDay\":\"singup_birthDay__2gLje\",\"switchContainer\":\"singup_switchContainer__3uClR\",\"error\":\"singup_error__usO7t\",\"close\":\"singup_close__3Wcb3\"};","import { isValidElement, useRef, useState, useCallback, useEffect, useMemo, createContext, useContext, createElement, cloneElement } from 'react';\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst SELECT = 'select';\r\nconst UNDEFINED = 'undefined';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nfunction attachEventListeners({ ref }, shouldAttachChangeEvent, handleChange) {\r\n    if (isHTMLElement(ref) && handleChange) {\r\n        ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n        ref.addEventListener(EVENTS.BLUR, handleChange);\r\n    }\r\n}\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !(value instanceof Date);\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar stringToPath = (input) => compact(input\r\n    .replace(/[\"|']/g, '')\r\n    .replace(/\\[/g, '.')\r\n    .replace(/\\]/g, '')\r\n    .split('.'));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar transformToNestObject = (data, value = {}) => {\r\n    for (const key in data) {\r\n        !isKey(key) ? set(value, key, data[key]) : (value[key] = data[key]);\r\n    }\r\n    return value;\r\n};\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj = {}, path, defaultValue) => {\r\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\r\n    for (const key in fields) {\r\n        if (get(fieldErrors, key)) {\r\n            const field = fields[key];\r\n            if (field) {\r\n                if (field.ref.focus && isUndefined(field.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (field.options) {\r\n                    field.options[0].ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (isHTMLElement(ref) && ref.removeEventListener) {\r\n        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n    }\r\n};\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.ref.checked\r\n        ? {\r\n            isValid: true,\r\n            value: option.ref.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.ref.checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || value === ''\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled, shouldKeepRawValue) {\r\n    const field = fieldsRef.current[name];\r\n    if (field) {\r\n        const { ref: { value, disabled }, ref, valueAsNumber, valueAsDate, setValueAs, } = field;\r\n        if (disabled && excludeDisabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field.options).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field.options).value;\r\n        }\r\n        return shouldKeepRawValue\r\n            ? value\r\n            : valueAsNumber\r\n                ? value === ''\r\n                    ? NaN\r\n                    : +value\r\n                : valueAsDate\r\n                    ? ref.valueAsDate\r\n                    : setValueAs\r\n                        ? setValueAs(value)\r\n                        : value;\r\n    }\r\n    if (shallowFieldsStateRef) {\r\n        return get(shallowFieldsStateRef.current, name);\r\n    }\r\n}\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\r\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {\r\n    const { ref, ref: { name }, } = field;\r\n    const fieldRef = fieldsRef.current[name];\r\n    if (!shouldUnregister) {\r\n        const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\r\n        !isUndefined(value) && set(shallowFieldsStateRef.current, name, value);\r\n    }\r\n    if (!ref.type || !fieldRef) {\r\n        delete fieldsRef.current[name];\r\n        return;\r\n    }\r\n    if (isRadioInput(ref) || isCheckBoxInput(ref)) {\r\n        if (Array.isArray(fieldRef.options) && fieldRef.options.length) {\r\n            compact(fieldRef.options).forEach((option = {}, index) => {\r\n                if ((isDetached(option.ref) && isSameRef(option, option.ref)) ||\r\n                    forceDelete) {\r\n                    removeAllEventListeners(option.ref, handleChange);\r\n                    unset(fieldRef.options, `[${index}]`);\r\n                }\r\n            });\r\n            if (fieldRef.options && !compact(fieldRef.options).length) {\r\n                delete fieldsRef.current[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fieldsRef.current[name];\r\n        }\r\n    }\r\n    else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        delete fieldsRef.current[name];\r\n    }\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction deepEqual(object1, object2, isErrorObject) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        object1 instanceof Date ||\r\n        object2 instanceof Date) {\r\n        return object1 === object2;\r\n    }\r\n    if (!isValidElement(object1)) {\r\n        const keys1 = Object.keys(object1);\r\n        const keys2 = Object.keys(object2);\r\n        if (keys1.length !== keys2.length) {\r\n            return false;\r\n        }\r\n        for (const key of keys1) {\r\n            const val1 = object1[key];\r\n            if (!(isErrorObject && key === 'ref')) {\r\n                const val2 = object2[key];\r\n                if ((isObject(val1) || Array.isArray(val1)) &&\r\n                    (isObject(val2) || Array.isArray(val2))\r\n                    ? !deepEqual(val1, val2, isErrorObject)\r\n                    : val1 !== val2) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nvar isString = (value) => typeof value === 'string';\n\nvar getFieldsValues = (fieldsRef, shallowFieldsState, shouldUnregister, excludeDisabled, search) => {\r\n    const output = {};\r\n    for (const name in fieldsRef.current) {\r\n        if (isUndefined(search) ||\r\n            (isString(search)\r\n                ? name.startsWith(search)\r\n                : Array.isArray(search) && search.find((data) => name.startsWith(data)))) {\r\n            output[name] = getFieldValue(fieldsRef, name, undefined, excludeDisabled);\r\n        }\r\n    }\r\n    return shouldUnregister\r\n        ? transformToNestObject(output)\r\n        : deepMerge(shallowFieldsState, transformToNestObject(output));\r\n};\n\nvar isErrorStateChanged = ({ errors, name, error, validFields, fieldsWithValidation, }) => {\r\n    const isValid = isUndefined(error);\r\n    const previousError = get(errors, name);\r\n    return ((isValid && !!previousError) ||\r\n        (!isValid && !deepEqual(previousError, error, true)) ||\r\n        (isValid && get(fieldsWithValidation, name) && !get(validFields, name)));\r\n};\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isMessage = (value) => isString(value) || isValidElement(value);\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { value }, options, required, maxLength, minLength, min, max, pattern, validate, }, shallowFieldsStateRef) => {\r\n    const name = ref.name;\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = value === '';\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, (exceedMax\r\n            ? appendErrorsCurry(maxType, message)\r\n            : appendErrorsCurry(minType, message)));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox\r\n                    ? ((fieldsRef.current[name].options || [])[0] || {}).ref\r\n                    : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) && value !== '') {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(value)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(value);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            value.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            value.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && pattern && !isEmpty) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef, false, true);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(fieldValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nconst getPath = (rootPath, values, paths = []) => {\r\n    for (const property in values) {\r\n        const rootName = (rootPath +\r\n            (isObject(values)\r\n                ? `.${property}`\r\n                : `[${property}]`));\r\n        isPrimitive(values[property])\r\n            ? paths.push(rootName)\r\n            : getPath(rootName, values[property], paths);\r\n    }\r\n    return paths;\r\n};\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\r\n    let value = undefined;\r\n    watchFields.add(fieldName);\r\n    if (!isEmptyObject(fieldValues)) {\r\n        value = get(fieldValues, fieldName);\r\n        if (isObject(value) || Array.isArray(value)) {\r\n            getPath(fieldName, value).forEach((name) => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isSingleField\r\n            ? inputValue\r\n            : get(inputValue, fieldName)\r\n        : value;\r\n};\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}([|.)\\\\d+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\r\nvar isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = (element) => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {\r\n    const observer = new MutationObserver(() => {\r\n        for (const field of Object.values(fieldsRef.current)) {\r\n            if (field && field.options) {\r\n                for (const option of field.options) {\r\n                    if (option && option.ref && isDetached(option.ref)) {\r\n                        removeFieldEventListenerAndRef(field);\r\n                    }\r\n                }\r\n            }\r\n            else if (field && isDetached(field.ref)) {\r\n                removeFieldEventListenerAndRef(field);\r\n            }\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nvar isWeb = typeof window !== UNDEFINED && typeof document !== UNDEFINED;\n\nfunction cloneObject(data) {\r\n    var _a;\r\n    let copy;\r\n    if (isPrimitive(data) ||\r\n        (isWeb && (data instanceof File || isHTMLElement(data)))) {\r\n        return data;\r\n    }\r\n    if (!['Set', 'Map', 'Object', 'Date', 'Array'].includes((_a = data.constructor) === null || _a === void 0 ? void 0 : _a.name)) {\r\n        return data;\r\n    }\r\n    if (data instanceof Date) {\r\n        copy = new Date(data.getTime());\r\n        return copy;\r\n    }\r\n    if (data instanceof Set) {\r\n        copy = new Set();\r\n        for (const item of data) {\r\n            copy.add(item);\r\n        }\r\n        return copy;\r\n    }\r\n    if (data instanceof Map) {\r\n        copy = new Map();\r\n        for (const key of data.keys()) {\r\n            copy.set(key, cloneObject(data.get(key)));\r\n        }\r\n        return copy;\r\n    }\r\n    copy = Array.isArray(data) ? [] : {};\r\n    for (const key in data) {\r\n        copy[key] = cloneObject(data[key]);\r\n    }\r\n    return copy;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nconst isWindowUndefined = typeof window === UNDEFINED;\r\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, shouldUnregister = true, criteriaMode, } = {}) {\r\n    const fieldsRef = useRef({});\r\n    const fieldArrayDefaultValuesRef = useRef({});\r\n    const fieldArrayValuesRef = useRef({});\r\n    const watchFieldsRef = useRef(new Set());\r\n    const useWatchFieldsRef = useRef({});\r\n    const useWatchRenderFunctionsRef = useRef({});\r\n    const fieldsWithValidationRef = useRef({});\r\n    const validFieldsRef = useRef({});\r\n    const defaultValuesRef = useRef(defaultValues);\r\n    const isUnMount = useRef(false);\r\n    const isWatchAllRef = useRef(false);\r\n    const handleChangeRef = useRef();\r\n    const shallowFieldsStateRef = useRef({});\r\n    const resetFieldArrayFunctionRef = useRef({});\r\n    const contextRef = useRef(context);\r\n    const resolverRef = useRef(resolver);\r\n    const fieldArrayNamesRef = useRef(new Set());\r\n    const modeRef = useRef(modeChecker(mode));\r\n    const { isOnSubmit, isOnTouch } = modeRef.current;\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const [formState, setFormState] = useState({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touched: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: !isOnSubmit,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = useRef({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touched: !isProxyEnabled || isOnTouch,\r\n        isValidating: !isProxyEnabled,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const formStateRef = useRef(formState);\r\n    const observerRef = useRef();\r\n    const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = useRef(modeChecker(reValidateMode)).current;\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    formStateRef.current = formState;\r\n    shallowFieldsStateRef.current = shouldUnregister\r\n        ? {}\r\n        : isEmptyObject(shallowFieldsStateRef.current)\r\n            ? cloneObject(defaultValues)\r\n            : shallowFieldsStateRef.current;\r\n    const updateFormState = useCallback((state = {}) => {\r\n        if (!isUnMount.current) {\r\n            formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);\r\n            setFormState(formStateRef.current);\r\n        }\r\n    }, []);\r\n    const updateIsValidating = () => readFormStateRef.current.isValidating &&\r\n        updateFormState({\r\n            isValidating: true,\r\n        });\r\n    const shouldRenderBaseOnError = useCallback((name, error, shouldRender = false, state = {}, isValid) => {\r\n        let shouldReRender = shouldRender ||\r\n            isErrorStateChanged({\r\n                errors: formStateRef.current.errors,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        if (error) {\r\n            unset(validFieldsRef.current, name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    !previousError ||\r\n                    !deepEqual(previousError, error, true);\r\n            set(formStateRef.current.errors, name, error);\r\n        }\r\n        else {\r\n            if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\r\n                set(validFieldsRef.current, name, true);\r\n                shouldReRender = shouldReRender || previousError;\r\n            }\r\n            unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((shouldReRender && !isNullOrUndefined(shouldRender)) ||\r\n            !isEmptyObject(state) ||\r\n            readFormStateRef.current.isValidating) {\r\n            updateFormState(Object.assign(Object.assign(Object.assign({}, state), (resolverRef.current ? { isValid: !!isValid } : {})), { isValidating: false }));\r\n        }\r\n    }, []);\r\n    const setFieldValue = useCallback((name, rawValue) => {\r\n        const { ref, options } = fieldsRef.current[name];\r\n        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(ref)) {\r\n            (options || []).forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isFileInput(ref) && !isString(value)) {\r\n            ref.files = value;\r\n        }\r\n        else if (isMultipleSelect(ref)) {\r\n            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(ref) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = Array.isArray(value)\r\n                    ? !!value.find((data) => data === checkboxRef.value)\r\n                    : value === checkboxRef.value))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n    }, []);\r\n    const isFormDirty = useCallback((name, data) => {\r\n        if (readFormStateRef.current.isDirty) {\r\n            const formValues = getValues();\r\n            name && data && set(formValues, name, data);\r\n            return !deepEqual(formValues, defaultValuesRef.current);\r\n        }\r\n        return false;\r\n    }, []);\r\n    const updateAndGetDirtyState = useCallback((name, shouldRender = true) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), getFieldValue(fieldsRef, name, shallowFieldsStateRef));\r\n            const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            isFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            const state = {\r\n                isDirty: isFormDirty(),\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            };\r\n            const isChanged = (readFormStateRef.current.isDirty &&\r\n                previousIsDirty !== state.isDirty) ||\r\n                (readFormStateRef.current.dirtyFields &&\r\n                    isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\r\n            isChanged && shouldRender && updateFormState(state);\r\n            return isChanged ? state : {};\r\n        }\r\n        return {};\r\n    }, []);\r\n    const executeValidation = useCallback(async (name, skipReRender) => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!fieldsRef.current[name]) {\r\n                console.warn(' Field is missing with `name` attribute: ', name);\r\n                return false;\r\n            }\r\n        }\r\n        const error = (await validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef))[name];\r\n        shouldRenderBaseOnError(name, error, skipReRender);\r\n        return isUndefined(error);\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = useCallback(async (names) => {\r\n        const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n        const previousFormIsValid = formStateRef.current.isValid;\r\n        if (Array.isArray(names)) {\r\n            const isInputsValid = names\r\n                .map((name) => {\r\n                const error = get(errors, name);\r\n                error\r\n                    ? set(formStateRef.current.errors, name, error)\r\n                    : unset(formStateRef.current.errors, name);\r\n                return !error;\r\n            })\r\n                .every(Boolean);\r\n            updateFormState({\r\n                isValid: isEmptyObject(errors),\r\n                isValidating: false,\r\n            });\r\n            return isInputsValid;\r\n        }\r\n        else {\r\n            const error = get(errors, names);\r\n            shouldRenderBaseOnError(names, error, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));\r\n            return !error;\r\n        }\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const trigger = useCallback(async (name) => {\r\n        const fields = name || Object.keys(fieldsRef.current);\r\n        updateIsValidating();\r\n        if (resolverRef.current) {\r\n            return executeSchemaOrResolverValidation(fields);\r\n        }\r\n        if (Array.isArray(fields)) {\r\n            !name && (formStateRef.current.errors = {});\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, null)));\r\n            updateFormState({\r\n                isValidating: false,\r\n            });\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields);\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = useCallback((name, value, { shouldDirty, shouldValidate }) => {\r\n        const data = {};\r\n        set(data, name, value);\r\n        for (const fieldName of getPath(name, value)) {\r\n            if (fieldsRef.current[fieldName]) {\r\n                setFieldValue(fieldName, get(data, fieldName));\r\n                shouldDirty && updateAndGetDirtyState(fieldName);\r\n                shouldValidate && trigger(fieldName);\r\n            }\r\n        }\r\n    }, [trigger, setFieldValue, updateAndGetDirtyState]);\r\n    const setInternalValue = useCallback((name, value, config) => {\r\n        !shouldUnregister &&\r\n            !isPrimitive(value) &&\r\n            set(shallowFieldsStateRef.current, name, Array.isArray(value) ? [...value] : Object.assign({}, value));\r\n        if (fieldsRef.current[name]) {\r\n            setFieldValue(name, value);\r\n            config.shouldDirty && updateAndGetDirtyState(name);\r\n            config.shouldValidate && trigger(name);\r\n        }\r\n        else if (!isPrimitive(value)) {\r\n            setInternalValues(name, value, config);\r\n            if (fieldArrayNamesRef.current.has(name)) {\r\n                const parentName = getFieldArrayParentName(name) || name;\r\n                set(fieldArrayDefaultValuesRef.current, name, value);\r\n                resetFieldArrayFunctionRef.current[parentName]({\r\n                    [parentName]: get(fieldArrayDefaultValuesRef.current, parentName),\r\n                });\r\n                if ((readFormStateRef.current.isDirty ||\r\n                    readFormStateRef.current.dirtyFields) &&\r\n                    config.shouldDirty) {\r\n                    set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                    updateFormState({\r\n                        isDirty: !deepEqual(Object.assign(Object.assign({}, getValues()), { [name]: value }), defaultValuesRef.current),\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\r\n    }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const renderWatchedInputs = (name) => {\r\n        let found = true;\r\n        if (!isEmptyObject(useWatchFieldsRef.current)) {\r\n            for (const key in useWatchFieldsRef.current) {\r\n                if (!name ||\r\n                    !useWatchFieldsRef.current[key].size ||\r\n                    useWatchFieldsRef.current[key].has(name) ||\r\n                    useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))) {\r\n                    useWatchRenderFunctionsRef.current[key]();\r\n                    found = false;\r\n                }\r\n            }\r\n        }\r\n        return found;\r\n    };\r\n    function setValue(name, value, config) {\r\n        setInternalValue(name, value, config || {});\r\n        isFieldWatched(name) && updateFormState();\r\n        renderWatchedInputs(name);\r\n    }\r\n    handleChangeRef.current = handleChangeRef.current\r\n        ? handleChangeRef.current\r\n        : async ({ type, target }) => {\r\n            let name = target.name;\r\n            const field = fieldsRef.current[name];\r\n            let error;\r\n            let isValid;\r\n            if (field) {\r\n                const isBlurEvent = type === EVENTS.BLUR;\r\n                const shouldSkipValidation = skipValidation(Object.assign({ isBlurEvent,\r\n                    isReValidateOnChange,\r\n                    isReValidateOnBlur, isTouched: !!get(formStateRef.current.touched, name), isSubmitted: formStateRef.current.isSubmitted }, modeRef.current));\r\n                let state = updateAndGetDirtyState(name, false);\r\n                let shouldRender = !isEmptyObject(state) ||\r\n                    (!isBlurEvent && isFieldWatched(name));\r\n                if (isBlurEvent &&\r\n                    !get(formStateRef.current.touched, name) &&\r\n                    readFormStateRef.current.touched) {\r\n                    set(formStateRef.current.touched, name, true);\r\n                    state = Object.assign(Object.assign({}, state), { touched: formStateRef.current.touched });\r\n                }\r\n                if (!shouldUnregister && isCheckBoxInput(target)) {\r\n                    set(shallowFieldsStateRef.current, name, getFieldValue(fieldsRef, name));\r\n                }\r\n                if (shouldSkipValidation) {\r\n                    !isBlurEvent && renderWatchedInputs(name);\r\n                    return ((!isEmptyObject(state) ||\r\n                        (shouldRender && isEmptyObject(state))) &&\r\n                        updateFormState(state));\r\n                }\r\n                updateIsValidating();\r\n                if (resolverRef.current) {\r\n                    const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n                    const previousFormIsValid = formStateRef.current.isValid;\r\n                    error = get(errors, name);\r\n                    if (isCheckBoxInput(target) &&\r\n                        !error &&\r\n                        resolverRef.current) {\r\n                        const parentNodeName = getFieldArrayParentName(name);\r\n                        const currentError = get(errors, parentNodeName, {});\r\n                        currentError.type &&\r\n                            currentError.message &&\r\n                            (error = currentError);\r\n                        if (parentNodeName &&\r\n                            (currentError ||\r\n                                get(formStateRef.current.errors, parentNodeName))) {\r\n                            name = parentNodeName;\r\n                        }\r\n                    }\r\n                    isValid = isEmptyObject(errors);\r\n                    previousFormIsValid !== isValid && (shouldRender = true);\r\n                }\r\n                else {\r\n                    error = (await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef))[name];\r\n                }\r\n                !isBlurEvent && renderWatchedInputs(name);\r\n                shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\r\n            }\r\n        };\r\n    function setFieldArrayDefaultValues(data) {\r\n        if (!shouldUnregister) {\r\n            let copy = cloneObject(data);\r\n            for (const value of fieldArrayNamesRef.current) {\r\n                if (isKey(value) && !copy[value]) {\r\n                    copy = Object.assign(Object.assign({}, copy), { [value]: [] });\r\n                }\r\n            }\r\n            return copy;\r\n        }\r\n        return data;\r\n    }\r\n    function getValues(payload) {\r\n        if (isString(payload)) {\r\n            return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\r\n        }\r\n        if (Array.isArray(payload)) {\r\n            const data = {};\r\n            for (const name of payload) {\r\n                set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\r\n            }\r\n            return data;\r\n        }\r\n        return setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister));\r\n    }\r\n    const validateResolver = useCallback(async (values = {}) => {\r\n        const newDefaultValues = isEmptyObject(fieldsRef.current)\r\n            ? defaultValuesRef.current\r\n            : {};\r\n        const { errors } = (await resolverRef.current(Object.assign(Object.assign(Object.assign({}, newDefaultValues), getValues()), values), contextRef.current, isValidateAllFieldCriteria)) || {};\r\n        const isValid = isEmptyObject(errors);\r\n        formStateRef.current.isValid !== isValid &&\r\n            updateFormState({\r\n                isValid,\r\n            });\r\n    }, [isValidateAllFieldCriteria]);\r\n    const removeFieldEventListener = useCallback((field, forceDelete) => {\r\n        findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete);\r\n        if (shouldUnregister) {\r\n            unset(validFieldsRef.current, field.ref.name);\r\n            unset(fieldsWithValidationRef.current, field.ref.name);\r\n        }\r\n    }, [shouldUnregister]);\r\n    const updateWatchedValue = useCallback((name) => {\r\n        if (isWatchAllRef.current) {\r\n            updateFormState();\r\n        }\r\n        else {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (watchField.startsWith(name)) {\r\n                    updateFormState();\r\n                    break;\r\n                }\r\n            }\r\n            renderWatchedInputs(name);\r\n        }\r\n    }, []);\r\n    const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\r\n        if (field) {\r\n            removeFieldEventListener(field, forceDelete);\r\n            if (shouldUnregister && !compact(field.options || []).length) {\r\n                unset(formStateRef.current.errors, field.ref.name);\r\n                set(formStateRef.current.dirtyFields, field.ref.name, true);\r\n                updateFormState({\r\n                    isDirty: isFormDirty(),\r\n                });\r\n                readFormStateRef.current.isValid &&\r\n                    resolverRef.current &&\r\n                    validateResolver();\r\n                updateWatchedValue(field.ref.name);\r\n            }\r\n        }\r\n    }, [validateResolver, removeFieldEventListener]);\r\n    function clearErrors(name) {\r\n        name &&\r\n            (Array.isArray(name) ? name : [name]).forEach((inputName) => fieldsRef.current[inputName] && isKey(inputName)\r\n                ? delete formStateRef.current.errors[inputName]\r\n                : unset(formStateRef.current.errors, inputName));\r\n        updateFormState({\r\n            errors: name ? formStateRef.current.errors : {},\r\n        });\r\n    }\r\n    function setError(name, error) {\r\n        const ref = (fieldsRef.current[name] || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        updateFormState({\r\n            isValid: false,\r\n        });\r\n        error.shouldFocus && ref && ref.focus && ref.focus();\r\n    }\r\n    const watchInternal = useCallback((fieldNames, defaultValue, watchId) => {\r\n        const watchFields = watchId\r\n            ? useWatchFieldsRef.current[watchId]\r\n            : watchFieldsRef.current;\r\n        let fieldValues = getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, false, fieldNames);\r\n        if (isString(fieldNames)) {\r\n            const parentNodeName = getFieldArrayParentName(fieldNames) || fieldNames;\r\n            if (fieldArrayNamesRef.current.has(parentNodeName)) {\r\n                fieldValues = Object.assign(Object.assign({}, fieldArrayValuesRef.current), fieldValues);\r\n            }\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(get(defaultValuesRef.current, fieldNames))\r\n                ? defaultValue\r\n                : get(defaultValuesRef.current, fieldNames), true);\r\n        }\r\n        const combinedDefaultValues = isUndefined(defaultValue)\r\n            ? defaultValuesRef.current\r\n            : defaultValue;\r\n        if (Array.isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});\r\n        }\r\n        isWatchAllRef.current = isUndefined(watchId);\r\n        return transformToNestObject((!isEmptyObject(fieldValues) && fieldValues) ||\r\n            combinedDefaultValues);\r\n    }, []);\r\n    function watch(fieldNames, defaultValue) {\r\n        return watchInternal(fieldNames, defaultValue);\r\n    }\r\n    function unregister(name) {\r\n        for (const fieldName of Array.isArray(name) ? name : [name]) {\r\n            removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\r\n        }\r\n    }\r\n    function registerFieldRef(ref, options = {}) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!ref.name) {\r\n                return console.warn(' Field is missing `name` attribute', ref, `https://react-hook-form.com/api#useForm`);\r\n            }\r\n            if (fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) &&\r\n                !RegExp(`^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`\r\n                    .replace(/\\[/g, '\\\\[')\r\n                    .replace(/\\]/g, '\\\\]')).test(ref.name)) {\r\n                return console.warn(' `name` prop should be in object shape: name=\"test[index].name\"', ref, 'https://react-hook-form.com/api#useFieldArray');\r\n            }\r\n        }\r\n        const { name, type, value } = ref;\r\n        const fieldRefAndValidationOptions = Object.assign({ ref }, options);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n        const compareRef = (currentRef) => isWeb && (!isHTMLElement(ref) || currentRef === ref);\r\n        let field = fields[name];\r\n        let isEmptyDefaultValue = true;\r\n        let defaultValue;\r\n        if (field &&\r\n            (isRadioOrCheckbox\r\n                ? Array.isArray(field.options) &&\r\n                    compact(field.options).find((option) => {\r\n                        return value === option.ref.value && compareRef(option.ref);\r\n                    })\r\n                : compareRef(field.ref))) {\r\n            fields[name] = Object.assign(Object.assign({}, field), options);\r\n            return;\r\n        }\r\n        if (type) {\r\n            field = isRadioOrCheckbox\r\n                ? Object.assign({ options: [\r\n                        ...compact((field && field.options) || []),\r\n                        {\r\n                            ref,\r\n                        },\r\n                    ], ref: { type, name } }, options) : Object.assign({}, fieldRefAndValidationOptions);\r\n        }\r\n        else {\r\n            field = fieldRefAndValidationOptions;\r\n        }\r\n        fields[name] = field;\r\n        const isEmptyUnmountFields = isUndefined(get(shallowFieldsStateRef.current, name));\r\n        if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\r\n            defaultValue = get(isEmptyUnmountFields\r\n                ? defaultValuesRef.current\r\n                : shallowFieldsStateRef.current, name);\r\n            isEmptyDefaultValue = isUndefined(defaultValue);\r\n            if (!isEmptyDefaultValue && !isFieldArray) {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        if (!isEmptyObject(options)) {\r\n            set(fieldsWithValidationRef.current, name, true);\r\n            if (!isOnSubmit && readFormStateRef.current.isValid) {\r\n                validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then((error) => {\r\n                    const previousFormIsValid = formStateRef.current.isValid;\r\n                    isEmptyObject(error)\r\n                        ? set(validFieldsRef.current, name, true)\r\n                        : unset(validFieldsRef.current, name);\r\n                    previousFormIsValid !== isEmptyObject(error) && updateFormState();\r\n                });\r\n            }\r\n        }\r\n        if (shouldUnregister && !(isFieldArray && isEmptyDefaultValue)) {\r\n            !isFieldArray && unset(formStateRef.current.dirtyFields, name);\r\n        }\r\n        if (type) {\r\n            attachEventListeners(isRadioOrCheckbox && field.options\r\n                ? field.options[field.options.length - 1]\r\n                : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\r\n        }\r\n    }\r\n    function register(refOrRegisterOptions, options) {\r\n        if (!isWindowUndefined) {\r\n            if (isString(refOrRegisterOptions)) {\r\n                registerFieldRef({ name: refOrRegisterOptions }, options);\r\n            }\r\n            else if (isObject(refOrRegisterOptions) &&\r\n                'name' in refOrRegisterOptions) {\r\n                registerFieldRef(refOrRegisterOptions, options);\r\n            }\r\n            else {\r\n                return (ref) => ref && registerFieldRef(ref, refOrRegisterOptions);\r\n            }\r\n        }\r\n    }\r\n    const handleSubmit = useCallback((onValid, onInvalid) => async (e) => {\r\n        if (e && e.preventDefault) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors = {};\r\n        let fieldValues = setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, true));\r\n        readFormStateRef.current.isSubmitting &&\r\n            updateFormState({\r\n                isSubmitting: true,\r\n            });\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\r\n                formStateRef.current.errors = fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                for (const field of Object.values(fieldsRef.current)) {\r\n                    if (field) {\r\n                        const { name } = field.ref;\r\n                        const fieldError = await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\r\n                        if (fieldError[name]) {\r\n                            set(fieldErrors, name, fieldError[name]);\r\n                            unset(validFieldsRef.current, name);\r\n                        }\r\n                        else if (get(fieldsWithValidationRef.current, name)) {\r\n                            unset(formStateRef.current.errors, name);\r\n                            set(validFieldsRef.current, name, true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isEmptyObject(fieldErrors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => name in fieldsRef.current)) {\r\n                updateFormState({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);\r\n                onInvalid && (await onInvalid(formStateRef.current.errors, e));\r\n                shouldFocusError &&\r\n                    focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\r\n            }\r\n        }\r\n        finally {\r\n            formStateRef.current.isSubmitting = false;\r\n            updateFormState({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n            });\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria]);\r\n    const resetRefs = ({ errors, isDirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {\r\n        if (!isValid) {\r\n            validFieldsRef.current = {};\r\n            fieldsWithValidationRef.current = {};\r\n        }\r\n        fieldArrayDefaultValuesRef.current = {};\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        updateFormState({\r\n            submitCount: submitCount ? formStateRef.current.submitCount : 0,\r\n            isDirty: isDirty ? formStateRef.current.isDirty : false,\r\n            isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\r\n            isValid: isValid ? formStateRef.current.isValid : false,\r\n            dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\r\n            touched: touched ? formStateRef.current.touched : {},\r\n            errors: errors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    };\r\n    const reset = (values, omitResetState = {}) => {\r\n        if (isWeb) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field) {\r\n                    const { ref, options } = field;\r\n                    const inputRef = isRadioOrCheckboxFunction(ref) && Array.isArray(options)\r\n                        ? options[0].ref\r\n                        : ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        fieldsRef.current = {};\r\n        defaultValuesRef.current = Object.assign({}, (values || defaultValuesRef.current));\r\n        values && renderWatchedInputs('');\r\n        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());\r\n        shallowFieldsStateRef.current = shouldUnregister\r\n            ? {}\r\n            : cloneObject(values || defaultValuesRef.current);\r\n        resetRefs(omitResetState);\r\n    };\r\n    useEffect(() => {\r\n        resolver && readFormStateRef.current.isValid && validateResolver();\r\n        observerRef.current =\r\n            observerRef.current || !isWeb\r\n                ? observerRef.current\r\n                : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\r\n    }, [removeFieldEventListenerAndRef, defaultValuesRef.current]);\r\n    useEffect(() => () => {\r\n        observerRef.current && observerRef.current.disconnect();\r\n        isUnMount.current = true;\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            return;\r\n        }\r\n        Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));\r\n    }, []);\r\n    if (!resolver && readFormStateRef.current.isValid) {\r\n        formState.isValid =\r\n            deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\r\n                isEmptyObject(formStateRef.current.errors);\r\n    }\r\n    const commonProps = {\r\n        trigger,\r\n        setValue: useCallback(setValue, [setInternalValue, trigger]),\r\n        getValues: useCallback(getValues, []),\r\n        register: useCallback(register, [defaultValuesRef.current]),\r\n        unregister: useCallback(unregister, []),\r\n        formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (process.env.NODE_ENV !== 'production') {\r\n                        if (prop === 'isValid' && isOnSubmit) {\r\n                            console.warn(' `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState');\r\n                        }\r\n                    }\r\n                    if (prop in obj) {\r\n                        readFormStateRef.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return undefined;\r\n                },\r\n            })\r\n            : formState,\r\n    };\r\n    const control = useMemo(() => (Object.assign({ isFormDirty,\r\n        updateWatchedValue,\r\n        shouldUnregister,\r\n        updateFormState,\r\n        removeFieldEventListener,\r\n        watchInternal, mode: modeRef.current, reValidateMode: {\r\n            isReValidateOnBlur,\r\n            isReValidateOnChange,\r\n        }, validateResolver: resolver ? validateResolver : undefined, fieldsRef,\r\n        resetFieldArrayFunctionRef,\r\n        useWatchFieldsRef,\r\n        useWatchRenderFunctionsRef,\r\n        fieldArrayDefaultValuesRef,\r\n        validFieldsRef,\r\n        fieldsWithValidationRef,\r\n        fieldArrayNamesRef,\r\n        readFormStateRef,\r\n        formStateRef,\r\n        defaultValuesRef,\r\n        shallowFieldsStateRef,\r\n        fieldArrayValuesRef }, commonProps)), [\r\n        defaultValuesRef.current,\r\n        updateWatchedValue,\r\n        shouldUnregister,\r\n        removeFieldEventListener,\r\n        watchInternal,\r\n    ]);\r\n    return Object.assign({ watch,\r\n        control,\r\n        handleSubmit, reset: useCallback(reset, []), clearErrors: useCallback(clearErrors, []), setError: useCallback(setError, []), errors: formState.errors }, commonProps);\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormContext = createContext(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => useContext(FormContext);\r\nconst FormProvider = (_a) => {\r\n    var { children } = _a, props = __rest(_a, [\"children\"]);\r\n    return (createElement(FormContext.Provider, { value: Object.assign({}, props) }, children));\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort((a, b) => a - b));\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    const temp = [data[indexB], data[indexA]];\r\n    data[indexA] = temp[0];\r\n    data[indexB] = temp[1];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\r\n}\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(Array.isArray(value) ? value : [value || undefined]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nvar fillBooleanArray = (value) => (Array.isArray(value) ? value : [value]).map((data) => {\r\n    if (isObject(data)) {\r\n        const object = {};\r\n        for (const key in data) {\r\n            object[key] = true;\r\n        }\r\n        return object;\r\n    }\r\n    return true;\r\n});\n\nconst mapIds = (values = [], keyName, skipWarn) => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!skipWarn) {\r\n            for (const value of values) {\r\n                if (typeof value === 'object') {\r\n                    if (keyName in value) {\r\n                        console.warn(` useFieldArray fieldValues contain the keyName \\`${keyName}\\` which is reserved for use by useFieldArray. https://react-hook-form.com/api#useFieldArray`);\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    console.warn(` useFieldArray input's name should be in object shape instead of flat array. https://react-hook-form.com/api#useFieldArray`);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return values.map((value) => (Object.assign({ [keyName]: value[keyName] || generateId() }, value)));\r\n};\r\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error(' useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray');\r\n        }\r\n    }\r\n    const focusIndexRef = useRef(-1);\r\n    const isUnMount = useRef(false);\r\n    const { isFormDirty, updateWatchedValue, resetFieldArrayFunctionRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, removeFieldEventListener, formStateRef, shallowFieldsStateRef, updateFormState, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, validateResolver, getValues, shouldUnregister, fieldArrayValuesRef, } = control || methods.control;\r\n    const getDefaultValues = (values) => get(shouldUnregister ? values : shallowFieldsStateRef.current, name, []);\r\n    const fieldArrayParentName = getFieldArrayParentName(name);\r\n    const memoizedDefaultValues = useRef([\r\n        ...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\r\n            ? getDefaultValues(fieldArrayDefaultValuesRef.current)\r\n            : getDefaultValues(defaultValuesRef.current)),\r\n    ]);\r\n    const [fields, setFields] = useState(mapIds(memoizedDefaultValues.current, keyName));\r\n    set(fieldArrayValuesRef.current, name, fields);\r\n    const omitKey = (fields) => fields.map((_a = {}) => {\r\n        var _b = keyName, omitted = _a[_b], rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\r\n        return rest;\r\n    });\r\n    fieldArrayNamesRef.current.add(name);\r\n    const getFieldArrayValue = useCallback(() => get(fieldArrayValuesRef.current, name, []), [name]);\r\n    const getCurrentFieldsValues = () => mapIds(get(getValues(), name, getFieldArrayValue()).map((item, index) => (Object.assign(Object.assign({}, getFieldArrayValue()[index]), item))), keyName, true);\r\n    fieldArrayNamesRef.current.add(name);\r\n    if (fieldArrayParentName &&\r\n        !get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\r\n        set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, cloneObject(get(defaultValuesRef.current, fieldArrayParentName)));\r\n    }\r\n    const setFieldAndValidState = (fieldsValues) => {\r\n        setFields(fieldsValues);\r\n        set(fieldArrayValuesRef.current, name, fieldsValues);\r\n        if (readFormStateRef.current.isValid && validateResolver) {\r\n            const values = getValues();\r\n            set(values, name, fieldsValues);\r\n            validateResolver(values);\r\n        }\r\n    };\r\n    const resetFields = () => {\r\n        for (const key in fieldsRef.current) {\r\n            if (isMatchFieldArrayName(key, name)) {\r\n                removeFieldEventListener(fieldsRef.current[key], true);\r\n                delete fieldsRef.current[key];\r\n            }\r\n        }\r\n    };\r\n    const cleanup = (ref) => !compact(get(ref, name, [])).length && unset(ref, name);\r\n    const updateDirtyFieldsWithDefaultValues = (updatedFieldArrayValues) => {\r\n        if (updatedFieldArrayValues) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n        }\r\n    };\r\n    const batchStateUpdate = (method, args, updatedFieldValues, updatedFormValues = [], shouldSet = true, shouldUpdateValid = false) => {\r\n        if (get(shallowFieldsStateRef.current, name)) {\r\n            const output = method(get(shallowFieldsStateRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(shallowFieldsStateRef.current, name, output);\r\n        }\r\n        if (get(fieldArrayDefaultValuesRef.current, name)) {\r\n            const output = method(get(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\r\n        }\r\n        if (Array.isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touched &&\r\n            get(formStateRef.current.touched, name)) {\r\n            const output = method(get(formStateRef.current.touched, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.touched, name, output);\r\n            cleanup(formStateRef.current.touched);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFormValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n            updateDirtyFieldsWithDefaultValues(updatedFieldValues);\r\n            cleanup(formStateRef.current.dirtyFields);\r\n        }\r\n        if (shouldUpdateValid &&\r\n            readFormStateRef.current.isValid &&\r\n            !validateResolver) {\r\n            set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\r\n            cleanup(validFieldsRef.current);\r\n            set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\r\n            cleanup(fieldsWithValidationRef.current);\r\n        }\r\n        if (!isUnMount.current && readFormStateRef.current.isDirty) {\r\n            updateFormState({\r\n                isDirty: isFormDirty(name, omitKey(updatedFormValues)),\r\n            });\r\n        }\r\n    };\r\n    const append = (value, shouldFocus = true) => {\r\n        const appendValue = Array.isArray(value) ? value : [value];\r\n        const updateFormValues = [\r\n            ...getCurrentFieldsValues(),\r\n            ...mapIds(appendValue, keyName),\r\n        ];\r\n        setFieldAndValidState(updateFormValues);\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            updateDirtyFieldsWithDefaultValues(updateFormValues);\r\n            updateFormState({\r\n                isDirty: true,\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            });\r\n        }\r\n        !shouldUnregister &&\r\n            set(shallowFieldsStateRef.current, name, [\r\n                ...(get(shallowFieldsStateRef.current, name) || []),\r\n                ...cloneObject(appendValue),\r\n            ]);\r\n        focusIndexRef.current = shouldFocus\r\n            ? get(fieldArrayValuesRef.current, name).length - 1\r\n            : -1;\r\n    };\r\n    const prepend$1 = (value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), mapIds(Array.isArray(value) ? value : [value], keyName));\r\n        setFieldAndValidState(updatedFieldArrayValues);\r\n        resetFields();\r\n        batchStateUpdate(prepend, {\r\n            argA: emptyArray,\r\n            argC: fillBooleanArray(value),\r\n        }, updatedFieldArrayValues);\r\n        focusIndexRef.current = shouldFocus ? 0 : -1;\r\n    };\r\n    const remove = (index) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        const updatedFieldValues = removeArrayAt(fieldValues, index);\r\n        setFieldAndValidState(updatedFieldValues);\r\n        resetFields();\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n            argC: index,\r\n        }, updatedFieldValues, removeArrayAt(fieldValues, index), true, true);\r\n    };\r\n    const insert$1 = (index, value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        const fieldValues = getCurrentFieldsValues();\r\n        const updatedFieldArrayValues = insert(fieldValues, index, mapIds(Array.isArray(value) ? value : [value], keyName));\r\n        setFieldAndValidState(updatedFieldArrayValues);\r\n        resetFields();\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: emptyArray,\r\n            argC: index,\r\n            argD: fillBooleanArray(value),\r\n        }, updatedFieldArrayValues, insert(fieldValues, index));\r\n        focusIndexRef.current = shouldFocus ? index : -1;\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        resetFields();\r\n        setFieldAndValidState([...fieldValues]);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n            argC: indexA,\r\n            argD: indexB,\r\n        }, undefined, fieldValues, false);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        resetFields();\r\n        setFieldAndValidState([...fieldValues]);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n            argC: from,\r\n            argD: to,\r\n        }, undefined, fieldValues, false);\r\n    };\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!name) {\r\n                console.warn(' useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray');\r\n            }\r\n        }\r\n        const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\r\n        if (defaultValues && fields.length < defaultValues.length) {\r\n            set(fieldArrayDefaultValuesRef.current, name, defaultValues.slice(1));\r\n        }\r\n        updateWatchedValue(name);\r\n        if (focusIndexRef.current > -1) {\r\n            for (const key in fieldsRef.current) {\r\n                const field = fieldsRef.current[key];\r\n                if (key.startsWith(`${name}[${focusIndexRef.current}]`) &&\r\n                    field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        focusIndexRef.current = -1;\r\n    }, [fields, name]);\r\n    useEffect(() => {\r\n        const resetFunctions = resetFieldArrayFunctionRef.current;\r\n        const fieldArrayNames = fieldArrayNamesRef.current;\r\n        if (!getFieldArrayParentName(name)) {\r\n            resetFunctions[name] = (data) => {\r\n                resetFields();\r\n                !data && unset(fieldArrayDefaultValuesRef.current, name);\r\n                unset(shallowFieldsStateRef.current, name);\r\n                memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\r\n                if (!isUnMount.current) {\r\n                    setFields(mapIds(memoizedDefaultValues.current, keyName));\r\n                }\r\n            };\r\n        }\r\n        return () => {\r\n            isUnMount.current = true;\r\n            shouldUnregister && remove();\r\n            resetFields();\r\n            delete resetFunctions[name];\r\n            unset(fieldArrayValuesRef.current, name);\r\n            fieldArrayNames.delete(name);\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: useCallback(swap, [name]),\r\n        move: useCallback(move, [name]),\r\n        prepend: useCallback(prepend$1, [name]),\r\n        append: useCallback(append, [name]),\r\n        remove: useCallback(remove, [name]),\r\n        insert: useCallback(insert$1, [name]),\r\n        fields,\r\n    };\r\n};\n\nvar getInputValue = (event) => isPrimitive(event) ||\r\n    !isObject(event.target) ||\r\n    (isObject(event.target) && !event.type)\r\n    ? event\r\n    : isUndefined(event.target.value)\r\n        ? event.target.checked\r\n        : event.target.value;\n\nfunction useController({ name, rules, defaultValue, control, onFocus, }) {\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error(' Controller is missing `control` prop. https://react-hook-form.com/api#Controller');\r\n        }\r\n    }\r\n    const { defaultValuesRef, setValue, register, unregister, trigger, mode, reValidateMode: { isReValidateOnBlur, isReValidateOnChange }, formState, formStateRef: { current: { isSubmitted, touched, errors }, }, updateFormState, readFormStateRef, fieldsRef, fieldArrayNamesRef, shallowFieldsStateRef, } = control || methods.control;\r\n    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    const getInitialValue = () => !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray\r\n        ? get(shallowFieldsStateRef.current, name)\r\n        : isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue;\r\n    const [value, setInputStateValue] = useState(getInitialValue());\r\n    const valueRef = useRef(value);\r\n    const ref = useRef({\r\n        focus: () => null,\r\n    });\r\n    const onFocusRef = useRef(onFocus ||\r\n        (() => {\r\n            if (isFunction(ref.current.focus)) {\r\n                ref.current.focus();\r\n            }\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                if (!isFunction(ref.current.focus)) {\r\n                    console.warn(` 'ref' from Controller render prop must be attached to a React component or a DOM Element whose ref provides a 'focus()' method`);\r\n                }\r\n            }\r\n        }));\r\n    const shouldValidate = useCallback((isBlurEvent) => !skipValidation(Object.assign({ isBlurEvent,\r\n        isReValidateOnBlur,\r\n        isReValidateOnChange,\r\n        isSubmitted, isTouched: !!get(touched, name) }, mode)), [\r\n        isReValidateOnBlur,\r\n        isReValidateOnChange,\r\n        isSubmitted,\r\n        touched,\r\n        name,\r\n        mode,\r\n    ]);\r\n    const commonTask = useCallback(([event]) => {\r\n        const data = getInputValue(event);\r\n        setInputStateValue(data);\r\n        valueRef.current = data;\r\n        return data;\r\n    }, []);\r\n    const registerField = useCallback((shouldUpdateValue) => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!name) {\r\n                return console.warn(' Field is missing `name` prop. https://react-hook-form.com/api#Controller');\r\n            }\r\n        }\r\n        if (fieldsRef.current[name]) {\r\n            fieldsRef.current[name] = Object.assign({ ref: fieldsRef.current[name].ref }, rules);\r\n        }\r\n        else {\r\n            register(Object.defineProperties({\r\n                name,\r\n                focus: onFocusRef.current,\r\n            }, {\r\n                value: {\r\n                    set(data) {\r\n                        setInputStateValue(data);\r\n                        valueRef.current = data;\r\n                    },\r\n                    get() {\r\n                        return valueRef.current;\r\n                    },\r\n                },\r\n            }), rules);\r\n            shouldUpdateValue = isUndefined(get(defaultValuesRef.current, name));\r\n        }\r\n        shouldUpdateValue &&\r\n            isNotFieldArray &&\r\n            setInputStateValue(getInitialValue());\r\n    }, [rules, name, register]);\r\n    useEffect(() => () => unregister(name), [name]);\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (isUndefined(value)) {\r\n                console.warn(` ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`);\r\n            }\r\n            if (!isNotFieldArray && isUndefined(defaultValue)) {\r\n                console.warn(' Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller');\r\n            }\r\n        }\r\n        registerField();\r\n    }, [registerField]);\r\n    useEffect(() => {\r\n        !fieldsRef.current[name] && registerField(true);\r\n    });\r\n    const onBlur = useCallback(() => {\r\n        if (readFormStateRef.current.touched && !get(touched, name)) {\r\n            set(touched, name, true);\r\n            updateFormState({\r\n                touched,\r\n            });\r\n        }\r\n        shouldValidate(true) && trigger(name);\r\n    }, [name, updateFormState, shouldValidate, trigger, readFormStateRef]);\r\n    const onChange = useCallback((...event) => setValue(name, commonTask(event), {\r\n        shouldValidate: shouldValidate(),\r\n        shouldDirty: true,\r\n    }), [setValue, name, shouldValidate]);\r\n    return {\r\n        field: {\r\n            onChange,\r\n            onBlur,\r\n            name,\r\n            value,\r\n            ref,\r\n        },\r\n        meta: Object.defineProperties({\r\n            invalid: !!get(errors, name),\r\n        }, {\r\n            isDirty: {\r\n                get() {\r\n                    return !!get(formState.dirtyFields, name);\r\n                },\r\n            },\r\n            isTouched: {\r\n                get() {\r\n                    return !!get(formState.touched, name);\r\n                },\r\n            },\r\n        }),\r\n    };\r\n}\n\nfunction useWatch({ control, name, defaultValue, }) {\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error(' useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch');\r\n        }\r\n    }\r\n    const { useWatchFieldsRef, useWatchRenderFunctionsRef, watchInternal, defaultValuesRef, } = control || methods.control;\r\n    const updateValue = useState()[1];\r\n    const idRef = useRef();\r\n    const defaultValueRef = useRef(defaultValue);\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (name === '') {\r\n                console.warn(' useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch');\r\n            }\r\n        }\r\n        const id = (idRef.current = generateId());\r\n        const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\r\n        const watchFieldsHook = useWatchFieldsRef.current;\r\n        watchFieldsHook[id] = new Set();\r\n        watchFieldsHookRender[id] = () => updateValue({});\r\n        watchInternal(name, defaultValueRef.current, id);\r\n        return () => {\r\n            delete watchFieldsHook[id];\r\n            delete watchFieldsHookRender[id];\r\n        };\r\n    }, [\r\n        name,\r\n        useWatchRenderFunctionsRef,\r\n        useWatchFieldsRef,\r\n        watchInternal,\r\n        defaultValueRef,\r\n    ]);\r\n    return idRef.current\r\n        ? watchInternal(name, defaultValueRef.current, idRef.current)\r\n        : isUndefined(defaultValue)\r\n            ? isString(name)\r\n                ? get(defaultValuesRef.current, name)\r\n                : Array.isArray(name)\r\n                    ? name.reduce((previous, inputName) => (Object.assign(Object.assign({}, previous), { [inputName]: get(defaultValuesRef.current, inputName) })), {})\r\n                    : defaultValuesRef.current\r\n            : defaultValue;\r\n}\n\nconst Controller = (props) => {\r\n    const { rules, as, render, defaultValue, control, onFocus } = props, rest = __rest(props, [\"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\r\n    const { field, meta } = useController(props);\r\n    const componentProps = Object.assign(Object.assign({}, rest), field);\r\n    return as\r\n        ? isValidElement(as)\r\n            ? cloneElement(as, componentProps)\r\n            : createElement(as, componentProps)\r\n        : render\r\n            ? render(field, meta)\r\n            : null;\r\n};\n\nexport { Controller, FormProvider, appendErrors, get, transformToNestObject, useController, useFieldArray, useForm, useFormContext, useWatch };\n//# sourceMappingURL=index.esm.js.map\n","import { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport _slicedToArray from \"F:/AHKI/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport React from 'react';\nimport Style from '../styles/singup.module.scss';\nimport LanguageContext from '../context/languageContext';\nimport Link from 'next/link';\nimport { DatePicker } from 'react-rainbow-components';\nimport PhoneInput from 'react-phone-input-2';\nimport { useForm } from 'react-hook-form';\nimport { Register } from '../services/user';\nimport VerifyAccount from '../components/verifyAccount/verifyAccount';\nimport PopUpMessage from '../components/popUpMessage/popUpMessage';\nimport ApiIsLoadingContext from '../context/apiIsLoadingContext';\nimport 'react-phone-input-2/lib/material.css';\n\nvar singup = function singup() {\n  var _React$useContext = React.useContext(LanguageContext),\n      _React$useContext2 = _slicedToArray(_React$useContext, 2),\n      language = _React$useContext2[0],\n      setLanguage = _React$useContext2[1];\n\n  var _React$useState = React.useState(\"email\"),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      showEmailOrTel = _React$useState2[0],\n      setShowEmailOrTel = _React$useState2[1];\n\n  var _React$useState3 = React.useState(\"1998-01-27T23:00:00.000Z\"),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      birthDay = _React$useState4[0],\n      setBirthDay = _React$useState4[1];\n\n  var _React$useState5 = React.useState({\n    state: false,\n    userid: \"\"\n  }),\n      _React$useState6 = _slicedToArray(_React$useState5, 2),\n      openVerifieAccountModal = _React$useState6[0],\n      setOpenVerifieAccountModal = _React$useState6[1];\n\n  var _useForm = useForm(),\n      register = _useForm.register,\n      handleSubmit = _useForm.handleSubmit,\n      errors = _useForm.errors,\n      watch = _useForm.watch;\n\n  var password = React.useRef({});\n  password.current = watch(\"password\", \"\");\n\n  var _React$useState7 = React.useState({\n    state: false,\n    text: \"\"\n  }),\n      _React$useState8 = _slicedToArray(_React$useState7, 2),\n      errorMessage = _React$useState8[0],\n      setErrorMessage = _React$useState8[1]; // when state true show  pop up \n\n\n  var _React$useContext3 = React.useContext(ApiIsLoadingContext),\n      _React$useContext4 = _slicedToArray(_React$useContext3, 2),\n      isLoading = _React$useContext4[0],\n      setIsLoading = _React$useContext4[1];\n\n  var onChangeHandlerRegisterPhone = function onChangeHandlerRegisterPhone(data, country) {\n    document.querySelector(\"#telId\").value = JSON.stringify({\n      \"dialCode\": country.dialCode,\n      'tel': data\n    });\n  };\n\n  var switchTo = function switchTo() {\n    setShowEmailOrTel(function (e) {\n      if (e == \"tel\") {\n        return \"email\";\n      } else {\n        return \"tel\";\n      }\n    });\n  };\n\n  var setBirthDayfn = function setBirthDayfn(date) {\n    setBirthDay(date);\n    document.querySelector(\"#ageId\").value = date;\n  };\n\n  var onSubmit = function onSubmit(data) {\n    setIsLoading(true);\n    Register(data).then(function (res) {\n      if (res.data == undefined) {\n        setIsLoading(false);\n      } else if (res.data.state == false) {\n        setErrorMessage({\n          state: true,\n          text: res.data.message\n        });\n        setIsLoading(false);\n      } else {\n        setOpenVerifieAccountModal({\n          state: true,\n          userid: res.data.userid\n        });\n        setIsLoading(false);\n      }\n    })[\"catch\"](function (error) {\n      setErrorMessage({\n        state: true,\n        text: error.message\n      });\n      setIsLoading(false);\n    });\n  };\n\n  var closePopUp = function closePopUp() {\n    setErrorMessage({\n      state: false,\n      text: \"\"\n    });\n  };\n\n  return /*#__PURE__*/_jsxs(\"div\", {\n    className: Style.pageContainer,\n    children: [errorMessage.state == true && /*#__PURE__*/_jsx(PopUpMessage, {\n      fnclose: closePopUp,\n      openPopUp: errorMessage\n    }), openVerifieAccountModal.state && /*#__PURE__*/_jsxs(_Fragment, {\n      children: [/*#__PURE__*/_jsx(\"div\", {\n        className: Style.close,\n        onClick: function onClick() {\n          return setOpenVerifieAccountModal({\n            state: false,\n            userid: \"\"\n          });\n        }\n      }), /*#__PURE__*/_jsx(VerifyAccount, {\n        userId: openVerifieAccountModal.userid\n      })]\n    }), /*#__PURE__*/_jsx(\"div\", {\n      className: Style.formContainer,\n      children: /*#__PURE__*/_jsxs(\"form\", {\n        onSubmit: handleSubmit(onSubmit),\n        children: [/*#__PURE__*/_jsx(\"input\", {\n          name: \"age\",\n          id: \"ageId\",\n          defaultValue: \"1998-01-27T23:00:00.000Z\",\n          ref: register({\n            required: \"Required\"\n          }),\n          style: {\n            position: \"absolute\",\n            opacity: 0,\n            pointerEvents: \"none\"\n          }\n        }), /*#__PURE__*/_jsx(\"div\", {\n          className: Style.Header,\n          children: /*#__PURE__*/_jsx(\"h1\", {\n            children: \"Sing up For NOZZLA\"\n          })\n        }), /*#__PURE__*/_jsx(\"div\", {\n          className: Style.descriptionHeader,\n          children: /*#__PURE__*/_jsx(\"h3\", {\n            children: language.createaprofilefollowotheraccountstalkaboutyourownexperienceandmore\n          })\n        }), /*#__PURE__*/_jsxs(\"div\", {\n          className: Style.inputContainer,\n          children: [/*#__PURE__*/_jsx(\"input\", {\n            className: Style.input,\n            ref: register,\n            name: \"userName\",\n            required: true\n          }), /*#__PURE__*/_jsx(\"label\", {\n            children: /*#__PURE__*/_jsx(\"span\", {\n              children: language.username\n            })\n          })]\n        }), /*#__PURE__*/_jsx(\"div\", {\n          className: Style.switchContainer,\n          children: /*#__PURE__*/_jsxs(\"p\", {\n            onClick: function onClick() {\n              return switchTo();\n            },\n            children: [\"siwtch to \", showEmailOrTel == \"tel\" ? \"email\" : \"tel\"]\n          })\n        }), /*#__PURE__*/_jsxs(\"div\", {\n          className: \"\".concat(Style.inputContainerTelOrEmail),\n          children: [/*#__PURE__*/_jsx(\"input\", {\n            type: \"text\",\n            name: \"tel\",\n            style: {\n              position: 'absolute',\n              pointerEvents: \"none\",\n              opacity: 0\n            }\n          }), showEmailOrTel == \"tel\" && /*#__PURE__*/_jsxs(_Fragment, {\n            children: [/*#__PURE__*/_jsx(\"input\", {\n              name: \"tel\",\n              id: \"telId\",\n              ref: register({\n                required: \"Required\"\n              }),\n              style: {\n                position: \"absolute\",\n                opacity: 0,\n                pointerEvents: \"none\"\n              }\n            }), /*#__PURE__*/_jsx(PhoneInput, {\n              name: \"tel\",\n              specialLabel: language.phone,\n              country: 'tn',\n              inputProps: {\n                name: 'phone',\n                required: true,\n                autoFocus: true\n              },\n              onChange: function onChange(e, country) {\n                return onChangeHandlerRegisterPhone(e, country);\n              }\n            })]\n          }), showEmailOrTel == \"email\" && /*#__PURE__*/_jsxs(\"div\", {\n            className: Style.inputContainer,\n            children: [/*#__PURE__*/_jsx(\"input\", {\n              name: \"email\",\n              ref: register({\n                required: \"Required\",\n                pattern: {\n                  value: /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,\n                  message: \"invalid email address\"\n                }\n              }),\n              className: Style.input,\n              required: true\n            }), /*#__PURE__*/_jsx(\"label\", {\n              children: /*#__PURE__*/_jsx(\"span\", {\n                children: \"email\"\n              })\n            })]\n          })]\n        }), errors.tel && /*#__PURE__*/_jsx(\"div\", {\n          className: Style.error,\n          children: /*#__PURE__*/_jsx(\"p\", {\n            children: \"tel is required\"\n          })\n        }), errors.email && /*#__PURE__*/_jsx(\"div\", {\n          className: Style.error,\n          children: /*#__PURE__*/_jsx(\"p\", {\n            children: \"email is incorect\"\n          })\n        }), /*#__PURE__*/_jsxs(\"div\", {\n          className: Style.inputContainer,\n          children: [/*#__PURE__*/_jsx(\"input\", {\n            name: \"password\",\n            type: \"password\",\n            ref: register({\n              required: \"password required\",\n              minLength: 8\n            }),\n            className: Style.input,\n            required: true\n          }), /*#__PURE__*/_jsx(\"label\", {\n            children: /*#__PURE__*/_jsx(\"span\", {\n              children: language.password\n            })\n          })]\n        }), errors.password && /*#__PURE__*/_jsx(\"div\", {\n          className: Style.error,\n          children: /*#__PURE__*/_jsx(\"p\", {\n            children: \"password length must be 8 at least\"\n          })\n        }), /*#__PURE__*/_jsxs(\"div\", {\n          className: Style.inputContainer,\n          children: [/*#__PURE__*/_jsx(\"input\", {\n            name: \"confirmPassword\",\n            type: \"password\",\n            ref: register({\n              validate: function validate(value) {\n                return value === password.current || \"The passwords do not match\";\n              }\n            }),\n            className: Style.input,\n            required: true\n          }), /*#__PURE__*/_jsx(\"label\", {\n            children: /*#__PURE__*/_jsx(\"span\", {\n              children: language.confirmpassword\n            })\n          })]\n        }), errors.confirmPassword && /*#__PURE__*/_jsxs(\"div\", {\n          className: Style.error,\n          children: [\" \", /*#__PURE__*/_jsx(\"p\", {\n            children: errors.confirmPassword.message\n          })]\n        }), /*#__PURE__*/_jsx(\"div\", {\n          className: \"\".concat(Style.inputContainer, \" \").concat(Style.birthDay),\n          children: /*#__PURE__*/_jsx(DatePicker, {\n            value: birthDay,\n            onChange: function onChange(value) {\n              return setBirthDayfn(value);\n            },\n            label: \"birth Day\",\n            formatStyle: \"large\",\n            locale: language.age\n          })\n        }), errors.age && /*#__PURE__*/_jsx(\"div\", {\n          className: Style.error,\n          children: /*#__PURE__*/_jsx(\"p\", {\n            children: \"age is required\"\n          })\n        }), /*#__PURE__*/_jsx(\"div\", {\n          className: Style.btnContainer,\n          children: /*#__PURE__*/_jsx(\"button\", {\n            children: language.signin\n          })\n        }), /*#__PURE__*/_jsx(\"div\", {\n          className: Style.messageToCreateAccounOrForgetPassword,\n          children: /*#__PURE__*/_jsxs(\"p\", {\n            className: Style.message,\n            children: [language.AlreadyHaveAccount, \" \", /*#__PURE__*/_jsx(Link, {\n              href: \"/signin\",\n              children: /*#__PURE__*/_jsx(\"span\", {\n                className: Style.clickHere,\n                children: language.signin\n              })\n            }), /*#__PURE__*/_jsx(\"br\", {}), \" \", /*#__PURE__*/_jsx(Link, {\n              href: \"/forgetPassword\",\n              children: /*#__PURE__*/_jsx(\"span\", {\n                className: Style.forgetPassword,\n                children: language.ForgotPassword\n              })\n            })]\n          })\n        })]\n      })\n    })]\n  });\n};\n\nexport default singup;","\n      (window.__NEXT_P = window.__NEXT_P || []).push([\n        \"/singup\",\n        function () {\n          return require(\"private-next-pages/singup.js\");\n        }\n      ]);\n    "]}}